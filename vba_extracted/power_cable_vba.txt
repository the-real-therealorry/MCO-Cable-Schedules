olevba 0.60.2 on Python 3.11.14 - http://decalage.info/python/oletools
===============================================================================
FILE: Power Cable Register Rev0.xlsm
Type: OpenXML
WARNING  For now, VBA stomping cannot be detected for files in memory
-------------------------------------------------------------------------------
VBA MACRO ThisWorkbook.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/ThisWorkbook'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' Author: jorr@mtcarbine.com.au
' Date 20-12-24
Option Explicit

Private Sub Workbook_Open()

    Dashboard.initialize
    Worksheets("Dashboard").Activate
    
End Sub


-------------------------------------------------------------------------------
VBA MACRO sht_WetPlant.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/sht_WetPlant'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: sht_WetPlant (Worksheet Class Module)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Manages cable data for the Wet Screen Crushing Plant. Provides CRUD
'          operations for cable records stored in the tbl_WetPlantCables Excel
'          table. Handles cable scheduling, circuit numbering, and data conversion
'          for the wet processing facility.
' ==============================================================================

Option Explicit

' ==============================================================================
' MODULE-LEVEL VARIABLES
' ==============================================================================

' Tracks the first empty row number (currently unused but may be for future functionality)
Dim lngFirstEmptyRow As Long

' ==============================================================================
' PUBLIC FUNCTIONS - TABLE ROW MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextEmptyRowNumber
' PURPOSE: Returns the row number where the next cable record should be added
' RETURNS: Long - Row number (table row count + 2 to account for header)
' NOTES: Adds 2 because ListRows.count doesn't include header, but we need
'        actual worksheet row number
'------------------------------------------------------------------------------
Public Function GetNextEmptyRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 2: +1 for header row, +1 for next empty row
    GetNextEmptyRowNumber = Me.ListObjects("tbl_WetPlantCables").ListRows.count + 2

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_WetPlant", "GetNextEmptyRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetLastRowNumber
' PURPOSE: Returns the row number of the last data row in the table
' RETURNS: Long - Last row number with data (table row count + 1 for header)
' NOTES: Different from GetNextEmptyRowNumber by 1 row
'------------------------------------------------------------------------------
Public Function GetLastRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 1 to account for header row
    GetLastRowNumber = Me.ListObjects("tbl_WetPlantCables").ListRows.count + 1

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_WetPlant", "GetLastRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetNumberOfCables
' PURPOSE: Returns the total number of cable records in the table
' RETURNS: Long - Count of cable records (excluding header)
' NOTES: Simple wrapper around ListRows.count for consistency
'------------------------------------------------------------------------------
Public Function GetNumberOfCables() As Long
    On Error GoTo ErrorHandler

    GetNumberOfCables = Me.ListObjects("tbl_WetPlantCables").ListRows.count

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_WetPlant", "GetNumberOfCables", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CABLE DATA MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetCablesArray
' PURPOSE: Retrieves all cable records as an array of clCable objects
' RETURNS: Variant - Array of clCable objects containing all cable data
' NOTES: Handles empty table case and maps table columns to object properties
'        Uses column constants (cc*) that should be defined elsewhere
'        Uses .Scheduled property (consistent with Retreatment module)
'------------------------------------------------------------------------------
Public Function GetCablesArray() As Variant
    On Error GoTo ErrorHandler
    
    Dim cTemp As New clCable
    Dim arrRows As Variant
    Dim arrCables() As New clCable
    
    ' Handle empty table case - return single empty element array
    If Me.GetNumberOfCables = 0 Then
        ReDim arrCables(1 To 1)
        GetCablesArray = arrCables
        Exit Function
        
    Else
        ' Get raw data from table (excludes header automatically)
        arrRows = sht_WetPlant.ListObjects("tbl_WetPlantCables").DataBodyRange.Value
        ReDim arrCables(1 To UBound(arrRows, 1))
        
    End If
    
    Dim lngRow As Long, lngCol As Long
    
    ' Process each row of data (header already excluded by DataBodyRange)
    For lngRow = 1 To UBound(arrRows, 1)
        ' Process each column and map to appropriate cable object property
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map columns to cable object properties using column constants
            If lngCol = ccScheduled Then
                arrCables(lngRow).Scheduled = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccIDAttached Then
                arrCables(lngRow).IDAttached = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCableID Then
                arrCables(lngRow).cableID = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccSource Then
                arrCables(lngRow).Source = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccDestination Then
                arrCables(lngRow).Destination = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCoreSize Then
                arrCables(lngRow).CoreSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccEarthsize Then
                arrCables(lngRow).EarthSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccoreconfig Then
                arrCables(lngRow).CoreConfig = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccinsulationtype Then
                arrCables(lngRow).InsulationType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccabletype Then
                arrCables(lngRow).CableType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccablelength Then
                arrCables(lngRow).CableLength = arrRows(lngRow, lngCol)
                
            End If
        
        Next lngCol
    Next lngRow
        
    ' Return the populated array of cable objects
    GetCablesArray = arrCables
    
    ' Clean up object references
    Set arrRows = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrRows = Nothing
    HandleError "sht_WetPlant", "GetCablesArray", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: ConvertCablesToRows
' PURPOSE: Converts an array of clCable objects back to a 2D array for table operations
' PARAMETERS: arrCables - Array of clCable objects to convert
' RETURNS: Variant - 2D array with cable data in table format
' NOTES: Inverse operation of GetCablesArray. Correctly uses .Scheduled property
'        (consistent with GetCablesArray, unlike OreSorter module)
'------------------------------------------------------------------------------
Public Function ConvertCablesToRows(ByVal arrCables As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' Create 2D array sized for cables count by total columns
    Dim arrRows() As Variant
    ReDim arrRows(1 To UBound(arrCables, 1), 1 To ccTotalColumns)
    
    Dim lngRow As Long
    Dim lngCol As Long
    
    ' Convert each cable object back to row format
    For lngRow = 1 To UBound(arrRows, 1)
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map cable object properties back to column positions
            ' NOTE: Correctly uses .Scheduled (consistent with GetCablesArray)
            If lngCol = ccScheduled Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Scheduled
                
            ElseIf lngCol = ccIDAttached Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).IDAttached
                
            ElseIf lngCol = ccCableID Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).cableID
                
            ElseIf lngCol = ccSource Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Source
                
            ElseIf lngCol = ccDestination Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Destination
                
            ElseIf lngCol = ccCoreSize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreSize
                
            ElseIf lngCol = ccEarthsize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).EarthSize
                
            ElseIf lngCol = cccoreconfig Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreConfig
                
            ElseIf lngCol = ccinsulationtype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).InsulationType
                
            ElseIf lngCol = cccabletype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableType
                
            ElseIf lngCol = cccablelength Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableLength
                
            End If
        Next lngCol
    Next lngRow
                
    ' Return the converted 2D array
    ConvertCablesToRows = arrRows
    
    ' Clean up object references
    Set arrCables = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrCables = Nothing
    HandleError "sht_WetPlant", "ConvertCablesToRows", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: SaveCable
' PURPOSE: Saves a new cable record to the table
' PARAMETERS: cNewCable - clCable object containing the cable data to save
' RETURNS: Long - The total number of cables after adding the new one
' NOTES: Uses the cable object's ToRow() method to get array representation
'        Hard-coded to 11 columns - should use constant for maintainability
'------------------------------------------------------------------------------
Public Function SaveCable(ByVal cNewCable As clCable) As Long
    On Error GoTo ErrorHandler
    
    ' Get cable data as array using the object's ToRow method
    Dim arrRow() As Variant
    arrRow = cNewCable.ToRow()
    
    ' Add new row to the table
    Dim lrNewRow As ListRow
    Set lrNewRow = Me.ListObjects("tbl_WetPlantCables").ListRows.Add
    
    ' Populate all columns with cable data
    Dim i As Long
    
    For i = 1 To ccTotalColumns
        lrNewRow.Range(i) = arrRow(i)
    Next i
        
    ' Return the total number of cables (including the new one)
    Dim lngNewRowNumber As Long
    lngNewRowNumber = Me.GetNumberOfCables()
    
    SaveCable = lngNewRowNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_WetPlant", "SaveCable", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CIRCUIT NUMBER MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextCircuitNumber
' PURPOSE: Calculates the next available circuit number by finding the highest existing one
' RETURNS: Long - Next sequential circuit number to use
' NOTES: Uses regex to extract circuit numbers from cable IDs and finds the maximum
'        Starting number is 1001, indicating Wet Plant designation (first plant type)
'        Processes column C which should contain CableID values
'        Pattern uses "1" to identify Wet Plant endpoints
'------------------------------------------------------------------------------
Public Function GetNextCircuitNumber() As Long
    On Error GoTo ErrorHandler

    Dim lngCurrent As Long
    Dim lngLastRow As Long
    Dim lngNextCircuitNumber As Long
    
    Dim lngHighest As Long
    lngHighest = 1001  ' (2001 for OreSorter, 3001 for Retreatment)
    
    Dim strPattern As String
    strPattern = "[A-Z]{2,3}[1][0-1][0-9]"
    
    Dim strItem As String
    Dim strCurrent As String
    
    lngLastRow = Me.GetLastRowNumber()
    
    Dim rItem As Range
    If lngLastRow > 1 Then
        For Each rItem In sht_WetPlant.Range("C2:C" & lngLastRow)
        
            ' DEFENSIVE: Handle empty, null, or error values
            If Not IsEmpty(rItem.Value) And Not IsNull(rItem.Value) And Not IsError(rItem.Value) Then
                strItem = Trim(CStr(rItem.Value))
                
                ' Only process if we have actual content
                If Len(strItem) > 0 Then
                    strCurrent = modUtils.RegexReplace(strItem, strPattern, "")
                    strCurrent = modUtils.RemoveChar(strCurrent, "-")
                    strCurrent = modUtils.RemoveChar(strCurrent, "C")
                    
                    ' Ensure result is numeric before converting
                    If IsNumeric(strCurrent) And Len(strCurrent) > 0 Then
                        lngCurrent = CLng(strCurrent)
                        
                        If lngCurrent > lngHighest Then
                            lngHighest = lngCurrent
                        End If
                    End If
                End If
            End If
        Next rItem
    
        lngNextCircuitNumber = lngHighest + 1
        
    Else
        lngNextCircuitNumber = lngHighest
        
    End If
    
    GetNextCircuitNumber = lngNextCircuitNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_WetPlant", "GetNextCircuitNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC SUBROUTINES - TABLE FORMATTING
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: ResetTableStyle
' PURPOSE: Resets the table formatting by clearing and reapplying the table style
' NOTES: Uses TableStyleMedium16 (different from other plants' styles)
'        Added error handling for consistency with other modules
'------------------------------------------------------------------------------
Public Sub ResetTableStyle()
On Error GoTo AIError

    ' Clear existing style then reapply to ensure clean formatting
    Me.ListObjects("tbl_WetPlantCables").TableStyle = ""
    Me.ListObjects("tbl_WetPlantCables").TableStyle = "TableStyleMedium16"

AIExit:
Exit Sub

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "sht_WetPlant", "ResetTableStyle", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

' ==============================================================================
' PRIVATE EVENT HANDLERS - WORKSHEET EVENTS
' ==============================================================================

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_SelectionChange
' PURPOSE: Handles user selection changes to manage row action buttons
' PARAMETERS: Target - The range that was selected
' NOTES: Only processes when worksheet is visible, delegates to ModRowActions
'        for button management logic. Already uses HandleError procedure.
'------------------------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    On Error GoTo CleanFail
    
    ' Only process selection changes when worksheet is visible to user
    If Me.Visible <> xlSheetVisible Then Exit Sub
    
    ' Delegate to external module for row button management
    ModRowActions.OnSelectionChangedForRowButtons Me, Target
    
    Exit Sub
    
CleanFail:
    ' Error handling with descriptive module name for context
    HandleError "Wet Screen Crushing Plant", "Worksheet_SelectionChange", Err.Number, Err.description, Erl
    
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_Deactivate
' PURPOSE: Cleans up row action buttons when user leaves this worksheet
' NOTES: Uses On Error Resume Next since this is cleanup code that shouldn't
'        interrupt user workflow if it fails
'------------------------------------------------------------------------------
Private Sub Worksheet_Deactivate()
    On Error Resume Next
    
    ' Hide row action buttons when leaving the worksheet
    ModRowActions.HideRowButtons Me
    
End Sub

' ==============================================================================
' ADD THESE METHODS TO EACH PLANT WORKSHEET MODULE
' (sht_WetPlant, sht_OreSorter, sht_Retreatment)
' ==============================================================================

' ==============================================================================
' FOR sht_WetPlant.cls
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: DeleteCableRow
' PURPOSE: Properly deletes a cable row from the Wet Plant cables table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' NOTES: Use this instead of manually deleting rows to maintain table integrity
'        This ensures the table structure remains valid after deletion
'------------------------------------------------------------------------------
Public Sub DeleteCableRow(lngRowIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_WetPlantCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Exit Sub
    End If
    
    ' Delete the entire ListRow properly (not just clear contents)
    Me.ListObjects("tbl_WetPlantCables").ListRows(lngRowIndex).Delete
    
    ' Optional: Show confirmation
    ' MsgBox "Cable deleted successfully.", vbInformation
    
ErrorExit:
Exit Sub

ErrorHandler:
    HandleError "sht_WetPlant", "DeleteCableRow", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' FUNCTION: GetCableByRowIndex
' PURPOSE: Retrieves a cable object from a specific table row
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' RETURNS: clCable object populated with data from the specified row, or Nothing if invalid
' NOTES: This method allows retrieval of a single cable for editing purposes
'------------------------------------------------------------------------------
Public Function GetCableByRowIndex(lngRowIndex As Long) As clCable
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_WetPlantCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Set GetCableByRowIndex = Nothing
        Exit Function
    End If
    
    ' Create new cable object to populate
    Dim cCable As New clCable
    
    ' Get the data from the specified row
    Dim arrData As Variant
    arrData = Me.ListObjects("tbl_WetPlantCables").ListRows(lngRowIndex).Range.Value
    
    ' Map table columns to cable object properties
    With cCable
        .Scheduled = arrData(1, ccScheduled)
        .IDAttached = arrData(1, ccIDAttached)
        .cableID = arrData(1, ccCableID)
        .Source = arrData(1, ccSource)
        .Destination = arrData(1, ccDestination)
        .CoreSize = arrData(1, ccCoreSize)
        .EarthSize = arrData(1, ccEarthsize)
        .CoreConfig = arrData(1, cccoreconfig)
        .InsulationType = arrData(1, ccinsulationtype)
        .CableType = arrData(1, cccabletype)
        .CableLength = arrData(1, cccablelength)
    End With
    
    ' Return the populated cable object
    Set GetCableByRowIndex = cCable
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_WetPlant", "GetCableByRowIndex", Err.Number, Err.description, Erl
    Set GetCableByRowIndex = Nothing
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: UpdateCable
' PURPOSE: Updates an existing cable record in the table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
'            cUpdatedCable - clCable object containing the updated cable data
' RETURNS: Boolean - True if update successful, False if failed
' NOTES: Replaces entire row with updated data from cable object
'------------------------------------------------------------------------------
Public Function UpdateCable(lngRowIndex As Long, cUpdatedCable As clCable) As Boolean
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_WetPlantCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        UpdateCable = False
        Exit Function
    End If
    
    ' Update the row with new cable data
    Dim arrRow As Variant
    arrRow = cUpdatedCable.ToRow()
    
    ' Write the updated data to the table row
    Me.ListObjects("tbl_WetPlantCables").ListRows(lngRowIndex).Range.Value = arrRow
    
    ' Return success
    UpdateCable = True
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_WetPlant", "UpdateCable", Err.Number, Err.description, Erl
    UpdateCable = False
    Resume ErrorExit
End Function
-------------------------------------------------------------------------------
VBA MACRO sht_OreSorter.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/sht_OreSorter'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: sht_OreSorter (Worksheet Class Module)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Manages cable data for the Ore Sorter plant. Provides CRUD operations
'          for cable records stored in the tbl_OreSorterCables Excel table.
'          Handles cable scheduling, circuit numbering, and data conversion.
' ==============================================================================

Option Explicit

' ==============================================================================
' MODULE-LEVEL VARIABLES
' ==============================================================================

' Tracks the first empty row number (currently unused but may be for future functionality)
Dim lngFirstEmptyRow As Long

' ==============================================================================
' PUBLIC FUNCTIONS - TABLE ROW MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextEmptyRowNumber
' PURPOSE: Returns the row number where the next cable record should be added
' RETURNS: Long - Row number (table row count + 2 to account for header)
' NOTES: Adds 2 because ListRows.count doesn't include header, but we need
'        actual worksheet row number
'------------------------------------------------------------------------------
Public Function GetNextEmptyRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 2: +1 for header row, +1 for next empty row
    GetNextEmptyRowNumber = Me.ListObjects("tbl_OreSorterCables").ListRows.count + 2

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_OreSorter", "GetNextEmptyRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetLastRowNumber
' PURPOSE: Returns the row number of the last data row in the table
' RETURNS: Long - Last row number with data (table row count + 1 for header)
' NOTES: Different from GetNextEmptyRowNumber by 1 row
'------------------------------------------------------------------------------
Public Function GetLastRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 1 to account for header row
    GetLastRowNumber = Me.ListObjects("tbl_OreSorterCables").ListRows.count + 1

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_OreSorter", "GetLastRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetNumberOfCables
' PURPOSE: Returns the total number of cable records in the table
' RETURNS: Long - Count of cable records (excluding header)
' NOTES: Simple wrapper around ListRows.count for consistency
'------------------------------------------------------------------------------
Public Function GetNumberOfCables() As Long
    On Error GoTo ErrorHandler

    GetNumberOfCables = Me.ListObjects("tbl_OreSorterCables").ListRows.count

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_OreSorter", "GetNumberOfCables", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CABLE DATA MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetCablesArray
' PURPOSE: Retrieves all cable records as an array of clCable objects
' RETURNS: Variant - Array of clCable objects containing all cable data
' NOTES: Handles empty table case and maps table columns to object properties
'        Uses column constants (cc*) that should be defined elsewhere
'------------------------------------------------------------------------------
Public Function GetCablesArray() As Variant
    On Error GoTo ErrorHandler
    
    Dim cTemp As New clCable
    Dim arrRows As Variant
    Dim arrCables() As New clCable
    
    ' Handle empty table case - return single empty element array
    If Me.GetNumberOfCables = 0 Then
        ReDim arrCables(1 To 1)
        GetCablesArray = arrCables
        Exit Function
        
    Else
        ' Get raw data from table (excludes header automatically)
        arrRows = sht_OreSorter.ListObjects("tbl_OreSorterCables").DataBodyRange.Value
        ReDim arrCables(1 To UBound(arrRows, 1))
        
    End If
    
    Dim lngRow As Long, lngCol As Long
    
    ' Process each row of data (header already excluded by DataBodyRange)
    For lngRow = 1 To UBound(arrRows, 1)
        ' Process each column and map to appropriate cable object property
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map columns to cable object properties using column constants
            If lngCol = ccScheduled Then
                arrCables(lngRow).Scheduled = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccIDAttached Then
                arrCables(lngRow).IDAttached = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCableID Then
                arrCables(lngRow).cableID = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccSource Then
                arrCables(lngRow).Source = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccDestination Then
                arrCables(lngRow).Destination = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCoreSize Then
                arrCables(lngRow).CoreSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccEarthsize Then
                arrCables(lngRow).EarthSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccoreconfig Then
                arrCables(lngRow).CoreConfig = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccinsulationtype Then
                arrCables(lngRow).InsulationType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccabletype Then
                arrCables(lngRow).CableType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccablelength Then
                arrCables(lngRow).CableLength = arrRows(lngRow, lngCol)
                
            End If
        
        Next lngCol
    Next lngRow
        
    ' Return the populated array of cable objects
    GetCablesArray = arrCables
    
    ' Clean up object references
    Set arrRows = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrRows = Nothing
    HandleError "sht_OreSorter", "GetCablesArray", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: ConvertCablesToRows
' PURPOSE: Converts an array of clCable objects back to a 2D array for table operations
' PARAMETERS: arrCables - Array of clCable objects to convert
' RETURNS: Variant - 2D array with cable data in table format
' NOTES: Inverse operation of GetCablesArray. Property name mismatch noted in
'        Schedule vs Scheduled (potential bug)
'------------------------------------------------------------------------------
Public Function ConvertCablesToRows(ByVal arrCables As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' Create 2D array sized for cables count by total columns
    Dim arrRows() As Variant
    ReDim arrRows(1 To UBound(arrCables, 1), 1 To ccTotalColumns)
    
    Dim lngRow As Long
    Dim lngCol As Long
    
    ' Convert each cable object back to row format
    For lngRow = 1 To UBound(arrRows, 1)
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map cable object properties back to column positions
            ' NOTE: Property name inconsistency - uses .Schedule here but .Scheduled in GetCablesArray
            If lngCol = ccScheduled Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Scheduled  ' POTENTIAL BUG: Should be .Scheduled?
                
            ElseIf lngCol = ccIDAttached Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).IDAttached
                
            ElseIf lngCol = ccCableID Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).cableID
                
            ElseIf lngCol = ccSource Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Source
                
            ElseIf lngCol = ccDestination Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Destination
                
            ElseIf lngCol = ccCoreSize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreSize
                
            ElseIf lngCol = ccEarthsize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).EarthSize
                
            ElseIf lngCol = cccoreconfig Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreConfig
                
            ElseIf lngCol = ccinsulationtype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).InsulationType
                
            ElseIf lngCol = cccabletype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableType
                
            ElseIf lngCol = cccablelength Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableLength
                
            End If
        Next lngCol
    Next lngRow
                
    ' Return the converted 2D array
    ConvertCablesToRows = arrRows
    
    ' Clean up object references
    ' Note: arrRows is a variant array, not an object, so no Set needed
    Set arrCables = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrCables = Nothing
    HandleError "sht_OreSorter", "ConvertCablesToRows", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: SaveCable
' PURPOSE: Saves a new cable record to the table
' PARAMETERS: cNewCable - clCable object containing the cable data to save
' RETURNS: Long - The total number of cables after adding the new one
' NOTES: Uses the cable object's ToRow() method to get array representation
'        Hard-coded to 11 columns - should use constant for maintainability
'------------------------------------------------------------------------------
Public Function SaveCable(ByVal cNewCable As clCable) As Long
    On Error GoTo ErrorHandler
    
    ' Get cable data as array using the object's ToRow method
    Dim arrRow() As Variant
    arrRow = cNewCable.ToRow()
    
    ' Add new row to the table
    Dim lrNewRow As ListRow
    Set lrNewRow = Me.ListObjects("tbl_OreSorterCables").ListRows.Add
    
    ' Populate all columns with cable data
    Dim i As Long
    
    For i = 1 To ccTotalColumns
        lrNewRow.Range(i) = arrRow(i)
    Next i
        
    ' Return the total number of cables (including the new one)
    Dim lngNewRowNumber As Long
    lngNewRowNumber = Me.GetNumberOfCables()
    
    SaveCable = lngNewRowNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_OreSorter", "SaveCable", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CIRCUIT NUMBER MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextCircuitNumber
' PURPOSE: Calculates the next available circuit number by finding the highest existing one
' RETURNS: Long - Next sequential circuit number to use
' NOTES: Uses regex to extract circuit numbers from cable IDs and finds the maximum
'        Starting number is 2001, suggesting a specific numbering scheme
'        Processes column C which should contain CableID values
'------------------------------------------------------------------------------
Public Function GetNextCircuitNumber() As Long
    On Error GoTo ErrorHandler

    Dim lngCurrent As Long
    Dim lngLastRow As Long
    Dim lngNextCircuitNumber As Long
    
    ' Starting point for circuit numbering (2001 suggests Ore Sorter plant designation)
    Dim lngHighest As Long
    lngHighest = 2001
    
    ' Regex pattern to match plant endpoint format: 2-3 letters + "2" + 2 digits
    ' The "2" indicates Ore Sorter plant (vs "1" for Wet Plant, "3" for Retreatment)
    Dim strPattern As String
    strPattern = "[A-Z]{2,3}[2][0-1][0-9]"
    
    Dim strItem As String
    Dim strCurrent As String
    
    ' Get the last row with data
    lngLastRow = Me.GetLastRowNumber()
    
    Dim rItem As Range
    If lngLastRow > 1 Then
        ' Scan through all CableID values in column C to find highest circuit number
        For Each rItem In sht_OreSorter.Range("C2:C" & lngLastRow)
        
            ' Convert cell value to string for processing
            strItem = CStr(rItem.Value)

            ' Only process non-empty cells
            If Not StrComp(strItem, "", vbTextCompare) = 0 Then
                ' Remove the plant designation pattern to isolate the circuit number
                strCurrent = modUtils.RegexReplace(strItem, strPattern, "")
                ' Remove common delimiters to get clean number
                strCurrent = modUtils.RemoveChar(strCurrent, "-")
                strCurrent = modUtils.RemoveChar(strCurrent, "C")
                
                ' Convert to number and track highest value found
                lngCurrent = CLng(strCurrent)
                
                If lngCurrent > lngHighest Then
                    lngHighest = lngCurrent
                End If
            End If
        Next rItem
    
        ' Return next sequential number
        lngNextCircuitNumber = lngHighest + 1
        
    Else
        ' No data exists, return starting number
        lngNextCircuitNumber = lngHighest
        
    End If
    
    GetNextCircuitNumber = lngNextCircuitNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_OreSorter", "GetNextCircuitNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC SUBROUTINES - TABLE FORMATTING
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: ResetTableStyle
' PURPOSE: Resets the table formatting by clearing and reapplying the table style
' NOTES: Uses TableStyleMedium19 - clearing first ensures clean application
'        Useful for refreshing table appearance after data changes
'------------------------------------------------------------------------------
Public Sub ResetTableStyle()
On Error GoTo AIError

    ' Clear existing style then reapply to ensure clean formatting
    Me.ListObjects("tbl_OreSorterCables").TableStyle = ""
    Me.ListObjects("tbl_OreSorterCables").TableStyle = "TableStyleMedium19"

AIExit:
Exit Sub

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "sht_OreSorter", "ResetTableStyle", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

' ==============================================================================
' PRIVATE EVENT HANDLERS - WORKSHEET EVENTS
' ==============================================================================

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_SelectionChange
' PURPOSE: Handles user selection changes to manage row action buttons
' PARAMETERS: Target - The range that was selected
' NOTES: Only processes when worksheet is visible, delegates to ModRowActions
'        for button management logic
'------------------------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    On Error GoTo CleanFail
    
    ' Only process selection changes when worksheet is visible to user
    If Me.Visible <> xlSheetVisible Then Exit Sub
    
    ' Delegate to external module for row button management
    ModRowActions.OnSelectionChangedForRowButtons Me, Target
    
    Exit Sub
    
CleanFail:
    ' Error handling with module name for context
    HandleError "Ore Sorting Plant", "Worksheet_SelectionChange", Err.Number, Err.description, Erl
    
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_Deactivate
' PURPOSE: Cleans up row action buttons when user leaves this worksheet
' NOTES: Uses On Error Resume Next since this is cleanup code that shouldn't
'        interrupt user workflow if it fails
'------------------------------------------------------------------------------
Private Sub Worksheet_Deactivate()
    On Error Resume Next
    
    ' Hide row action buttons when leaving the worksheet
    ModRowActions.HideRowButtons Me
    
End Sub

' ==============================================================================
' FOR sht_OreSorter.cls
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: DeleteCableRow
' PURPOSE: Properly deletes a cable row from the Ore Sorter cables table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' NOTES: Use this instead of manually deleting rows to maintain table integrity
'        This ensures the table structure remains valid after deletion
'------------------------------------------------------------------------------
Public Sub DeleteCableRow(lngRowIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_OreSorterCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Exit Sub
    End If
    
    ' Delete the entire ListRow properly (not just clear contents)
    Me.ListObjects("tbl_OreSorterCables").ListRows(lngRowIndex).Delete
    
    ' Optional: Show confirmation
    ' MsgBox "Cable deleted successfully.", vbInformation
    
ErrorExit:
Exit Sub

ErrorHandler:
    HandleError "sht_OreSorter", "DeleteCableRow", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' FUNCTION: GetCableByRowIndex
' PURPOSE: Retrieves a cable object from a specific table row
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' RETURNS: clCable object populated with data from the specified row, or Nothing if invalid
' NOTES: This method allows retrieval of a single cable for editing purposes
'------------------------------------------------------------------------------
Public Function GetCableByRowIndex(lngRowIndex As Long) As clCable
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_OreSorterCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Set GetCableByRowIndex = Nothing
        Exit Function
    End If
    
    ' Create new cable object to populate
    Dim cCable As New clCable
    
    ' Get the data from the specified row
    Dim arrData As Variant
    arrData = Me.ListObjects("tbl_OreSorterCables").ListRows(lngRowIndex).Range.Value
    
    ' Map table columns to cable object properties
    With cCable
        .Scheduled = arrData(1, ccScheduled)
        .IDAttached = arrData(1, ccIDAttached)
        .cableID = arrData(1, ccCableID)
        .Source = arrData(1, ccSource)
        .Destination = arrData(1, ccDestination)
        .CoreSize = arrData(1, ccCoreSize)
        .EarthSize = arrData(1, ccEarthsize)
        .CoreConfig = arrData(1, cccoreconfig)
        .InsulationType = arrData(1, ccinsulationtype)
        .CableType = arrData(1, cccabletype)
        .CableLength = arrData(1, cccablelength)
    End With
    
    ' Return the populated cable object
    Set GetCableByRowIndex = cCable
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_OreSorter", "GetCableByRowIndex", Err.Number, Err.description, Erl
    Set GetCableByRowIndex = Nothing
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: UpdateCable
' PURPOSE: Updates an existing cable record in the table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
'            cUpdatedCable - clCable object containing the updated cable data
' RETURNS: Boolean - True if update successful, False if failed
' NOTES: Replaces entire row with updated data from cable object
'------------------------------------------------------------------------------
Public Function UpdateCable(lngRowIndex As Long, cUpdatedCable As clCable) As Boolean
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_OreSorterCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        UpdateCable = False
        Exit Function
    End If
    
    ' Update the row with new cable data
    Dim arrRow As Variant
    arrRow = cUpdatedCable.ToRow()
    
    ' Write the updated data to the table row
    Me.ListObjects("tbl_OreSorterCables").ListRows(lngRowIndex).Range.Value = arrRow
    
    ' Return success
    UpdateCable = True
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_OreSorter", "UpdateCable", Err.Number, Err.description, Erl
    UpdateCable = False
    Resume ErrorExit
End Function
-------------------------------------------------------------------------------
VBA MACRO sht_Retreatment.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/sht_Retreatment'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: sht_Retreatment (Worksheet Class Module)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Manages cable data for the Retreatment Gravity Plant. Provides CRUD
'          operations for cable records stored in the tbl_RetreatmentCables
'          Excel table. Handles cable scheduling, circuit numbering, and data
'          conversion for the retreatment facility.
' ==============================================================================

Option Explicit

' ==============================================================================
' MODULE-LEVEL VARIABLES
' ==============================================================================

' Tracks the first empty row number (currently unused but may be for future functionality)
Dim lngFirstEmptyRow As Long

' ==============================================================================
' PUBLIC FUNCTIONS - TABLE ROW MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextEmptyRowNumber
' PURPOSE: Returns the row number where the next cable record should be added
' RETURNS: Long - Row number (table row count + 2 to account for header)
' NOTES: Adds 2 because ListRows.count doesn't include header, but we need
'        actual worksheet row number
'------------------------------------------------------------------------------
Public Function GetNextEmptyRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 2: +1 for header row, +1 for next empty row
    GetNextEmptyRowNumber = Me.ListObjects("tbl_RetreatmentCables").ListRows.count + 2

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_Retreatment", "GetNextEmptyRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetLastRowNumber
' PURPOSE: Returns the row number of the last data row in the table
' RETURNS: Long - Last row number with data (table row count + 1 for header)
' NOTES: Different from GetNextEmptyRowNumber by 1 row
'------------------------------------------------------------------------------
Public Function GetLastRowNumber() As Long
    On Error GoTo ErrorHandler

    ' Add 1 to account for header row
    GetLastRowNumber = Me.ListObjects("tbl_RetreatmentCables").ListRows.count + 1

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_Retreatment", "GetLastRowNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetNumberOfCables
' PURPOSE: Returns the total number of cable records in the table
' RETURNS: Long - Count of cable records (excluding header)
' NOTES: Simple wrapper around ListRows.count for consistency
'------------------------------------------------------------------------------
Public Function GetNumberOfCables() As Long
    On Error GoTo ErrorHandler

    GetNumberOfCables = Me.ListObjects("tbl_RetreatmentCables").ListRows.count

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_Retreatment", "GetNumberOfCables", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CABLE DATA MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetCablesArray
' PURPOSE: Retrieves all cable records as an array of clCable objects
' RETURNS: Variant - Array of clCable objects containing all cable data
' NOTES: Handles empty table case and maps table columns to object properties
'        Uses column constants (cc*) that should be defined elsewhere
'        Uses .Scheduled property (consistent with other modules)
'------------------------------------------------------------------------------
Public Function GetCablesArray() As Variant
    On Error GoTo ErrorHandler
    
    Dim cTemp As New clCable
    Dim arrRows As Variant
    Dim arrCables() As New clCable
    
    ' Handle empty table case - return single empty element array
    If Me.GetNumberOfCables = 0 Then
        ReDim arrCables(1 To 1)
        GetCablesArray = arrCables
        Exit Function
        
    Else
        ' Get raw data from table (excludes header automatically)
        arrRows = sht_Retreatment.ListObjects("tbl_RetreatmentCables").DataBodyRange.Value
        ReDim arrCables(1 To UBound(arrRows, 1))
        
    End If
    
    Dim lngRow As Long, lngCol As Long
    
    ' Process each row of data (header already excluded by DataBodyRange)
    For lngRow = 1 To UBound(arrRows, 1)
        ' Process each column and map to appropriate cable object property
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map columns to cable object properties using column constants
            If lngCol = ccScheduled Then
                arrCables(lngRow).Scheduled = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccIDAttached Then
                arrCables(lngRow).IDAttached = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCableID Then
                arrCables(lngRow).cableID = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccSource Then
                arrCables(lngRow).Source = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccDestination Then
                arrCables(lngRow).Destination = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCoreSize Then
                arrCables(lngRow).CoreSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccEarthsize Then
                arrCables(lngRow).EarthSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccoreconfig Then
                arrCables(lngRow).CoreConfig = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccinsulationtype Then
                arrCables(lngRow).InsulationType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccabletype Then
                arrCables(lngRow).CableType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccablelength Then
                arrCables(lngRow).CableLength = arrRows(lngRow, lngCol)
                
            End If
        
        Next lngCol
    Next lngRow
        
    ' Return the populated array of cable objects
    GetCablesArray = arrCables
    
    ' Clean up object references
    Set arrRows = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrRows = Nothing
    HandleError "sht_Retreatment", "GetCablesArray", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: ConvertCablesToRows
' PURPOSE: Converts an array of clCable objects back to a 2D array for table operations
' PARAMETERS: arrCables - Array of clCable objects to convert
' RETURNS: Variant - 2D array with cable data in table format
' NOTES: Inverse operation of GetCablesArray. Correctly uses .Scheduled property
'        (consistent with GetCablesArray unlike OreSorter module)
'------------------------------------------------------------------------------
Public Function ConvertCablesToRows(ByVal arrCables As Variant) As Variant
    On Error GoTo ErrorHandler
    
    ' Create 2D array sized for cables count by total columns
    Dim arrRows() As Variant
    ReDim arrRows(1 To UBound(arrCables, 1), 1 To ccTotalColumns)
    
    Dim lngRow As Long
    Dim lngCol As Long
    
    ' Convert each cable object back to row format
    For lngRow = 1 To UBound(arrRows, 1)
        For lngCol = 1 To UBound(arrRows, 2)
            ' Map cable object properties back to column positions
            ' NOTE: Correctly uses .Scheduled (consistent with GetCablesArray)
            If lngCol = ccScheduled Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Scheduled
                
            ElseIf lngCol = ccIDAttached Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).IDAttached
                
            ElseIf lngCol = ccCableID Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).cableID
                
            ElseIf lngCol = ccSource Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Source
                
            ElseIf lngCol = ccDestination Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).Destination
                
            ElseIf lngCol = ccCoreSize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreSize
                
            ElseIf lngCol = ccEarthsize Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).EarthSize
                
            ElseIf lngCol = cccoreconfig Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CoreConfig
                
            ElseIf lngCol = ccinsulationtype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).InsulationType
                
            ElseIf lngCol = cccabletype Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableType
                
            ElseIf lngCol = cccablelength Then
                arrRows(lngRow, lngCol) = arrCables(lngRow).CableLength
                
            End If
        Next lngCol
    Next lngRow
                
    ' Return the converted 2D array
    ConvertCablesToRows = arrRows
    
    ' Clean up object references
    Set arrCables = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrCables = Nothing
    HandleError "sht_Retreatment", "ConvertCablesToRows", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: SaveCable
' PURPOSE: Saves a new cable record to the table
' PARAMETERS: cNewCable - clCable object containing the cable data to save
' RETURNS: Long - The total number of cables after adding the new one
' NOTES: Uses the cable object's ToRow() method to get array representation
'        Hard-coded to 11 columns - should use constant for maintainability
'------------------------------------------------------------------------------
Public Function SaveCable(ByVal cNewCable As clCable) As Long
    On Error GoTo ErrorHandler
    
    ' Get cable data as array using the object's ToRow method
    Dim arrRow() As Variant
    arrRow = cNewCable.ToRow()
    
    ' Add new row to the table
    Dim lrNewRow As ListRow
    Set lrNewRow = Me.ListObjects("tbl_RetreatmentCables").ListRows.Add
    
    ' Populate all columns with cable data
    Dim i As Long
    
    For i = 1 To ccTotalColumns
        lrNewRow.Range(i) = arrRow(i)
    Next i
        
    ' Return the total number of cables (including the new one)
    Dim lngNewRowNumber As Long
    lngNewRowNumber = Me.GetNumberOfCables()
    
    SaveCable = lngNewRowNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_Retreatment", "SaveCable", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CIRCUIT NUMBER MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetNextCircuitNumber
' PURPOSE: Calculates the next available circuit number by finding the highest existing one
' RETURNS: Long - Next sequential circuit number to use
' NOTES: Uses regex to extract circuit numbers from cable IDs and finds the maximum
'        Starting number is 3001, indicating Retreatment plant designation (vs 1001/2001)
'        Processes column C which should contain CableID values
'        Pattern uses "3" to identify Retreatment plant endpoints
'------------------------------------------------------------------------------
Public Function GetNextCircuitNumber() As Long
    On Error GoTo ErrorHandler

    Dim lngCurrent As Long
    Dim lngLastRow As Long
    Dim lngNextCircuitNumber As Long
    
    ' Starting point for Retreatment circuit numbering (3001 indicates plant type)
    Dim lngHighest As Long
    lngHighest = 3001
    
    ' Regex pattern to match Retreatment plant endpoint format: 2-3 letters + "3" + 2 digits
    ' The "3" indicates Retreatment plant (vs "1" for Wet Plant, "2" for Ore Sorter)
    Dim strPattern As String
    strPattern = "[A-Z]{2,3}[3][0-1][0-9]"
    
    Dim strItem As String
    Dim strCurrent As String
    
    ' Get the last row with data
    lngLastRow = Me.GetLastRowNumber()
    
    Dim rItem As Range
    If lngLastRow > 1 Then
        ' Scan through all CableID values in column C to find highest circuit number
        For Each rItem In sht_Retreatment.Range("C2:C" & lngLastRow)
        
            ' Convert cell value to string for processing
            strItem = CStr(rItem.Value)

            ' Only process non-empty cells
            If Not StrComp(strItem, "", vbTextCompare) = 0 Then
                ' Remove the plant designation pattern to isolate the circuit number
                strCurrent = modUtils.RegexReplace(strItem, strPattern, "")
                ' Remove common delimiters to get clean number
                strCurrent = modUtils.RemoveChar(strCurrent, "-")
                strCurrent = modUtils.RemoveChar(strCurrent, "C")
                
                ' Convert to number and track highest value found
                lngCurrent = CLng(strCurrent)
                
                If lngCurrent > lngHighest Then
                    lngHighest = lngCurrent
                End If
            End If
        Next rItem
    
        ' Return next sequential number
        lngNextCircuitNumber = lngHighest + 1
        
    Else
        ' No data exists, return starting number
        lngNextCircuitNumber = lngHighest
        
    End If
    
    GetNextCircuitNumber = lngNextCircuitNumber
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "sht_Retreatment", "GetNextCircuitNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC SUBROUTINES - TABLE FORMATTING
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: ResetTableStyle
' PURPOSE: Resets the table formatting by clearing and reapplying the table style
' NOTES: Uses TableStyleMedium8 (different from OreSorter's Medium19)
'        Missing error handling - should be added for consistency
'------------------------------------------------------------------------------
Public Sub ResetTableStyle()
On Error GoTo AIError

    ' Clear existing style then reapply to ensure clean formatting
    Me.ListObjects("tbl_RetreatmentCables").TableStyle = ""
    Me.ListObjects("tbl_RetreatmentCables").TableStyle = "TableStyleMedium8"

AIExit:
Exit Sub

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "sht_Retreatment", "ResetTableStyle", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

' ==============================================================================
' PRIVATE EVENT HANDLERS - WORKSHEET EVENTS
' ==============================================================================

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_SelectionChange
' PURPOSE: Handles user selection changes to manage row action buttons
' PARAMETERS: Target - The range that was selected
' NOTES: Only processes when worksheet is visible, delegates to ModRowActions
'        for button management logic. Already uses HandleError procedure.
'------------------------------------------------------------------------------
Private Sub Worksheet_SelectionChange(ByVal Target As Range)
    On Error GoTo CleanFail
    
    ' Only process selection changes when worksheet is visible to user
    If Me.Visible <> xlSheetVisible Then Exit Sub
    
    ' Delegate to external module for row button management
    ModRowActions.OnSelectionChangedForRowButtons Me, Target
    
    Exit Sub
    
CleanFail:
    ' Error handling with descriptive module name for context
    HandleError "Retreatment Gravity Plant", "Worksheet_SelectionChange", Err.Number, Err.description, Erl
    
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: Worksheet_Deactivate
' PURPOSE: Cleans up row action buttons when user leaves this worksheet
' NOTES: Uses On Error Resume Next since this is cleanup code that shouldn't
'        interrupt user workflow if it fails
'------------------------------------------------------------------------------
Private Sub Worksheet_Deactivate()
    On Error Resume Next
    
    ' Hide row action buttons when leaving the worksheet
    ModRowActions.HideRowButtons Me
    
End Sub

' ==============================================================================
' FOR sht_Retreatment.cls
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: DeleteCableRow
' PURPOSE: Properly deletes a cable row from the Retreatment cables table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' NOTES: Use this instead of manually deleting rows to maintain table integrity
'        This ensures the table structure remains valid after deletion
'------------------------------------------------------------------------------
Public Sub DeleteCableRow(lngRowIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_RetreatmentCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Exit Sub
    End If
    
    ' Delete the entire ListRow properly (not just clear contents)
    Me.ListObjects("tbl_RetreatmentCables").ListRows(lngRowIndex).Delete
    
    ' Optional: Show confirmation
    ' MsgBox "Cable deleted successfully.", vbInformation
    
ErrorExit:
Exit Sub

ErrorHandler:
    HandleError "sht_Retreatment", "DeleteCableRow", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' FUNCTION: GetCableByRowIndex
' PURPOSE: Retrieves a cable object from a specific table row
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
' RETURNS: clCable object populated with data from the specified row, or Nothing if invalid
' NOTES: This method allows retrieval of a single cable for editing purposes
'------------------------------------------------------------------------------
Public Function GetCableByRowIndex(lngRowIndex As Long) As clCable
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_RetreatmentCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        Set GetCableByRowIndex = Nothing
        Exit Function
    End If
    
    ' Create new cable object to populate
    Dim cCable As New clCable
    
    ' Get the data from the specified row
    Dim arrData As Variant
    arrData = Me.ListObjects("tbl_RetreatmentCables").ListRows(lngRowIndex).Range.Value
    
    ' Map table columns to cable object properties
    With cCable
        .Scheduled = arrData(1, ccScheduled)
        .IDAttached = arrData(1, ccIDAttached)
        .cableID = arrData(1, ccCableID)
        .Source = arrData(1, ccSource)
        .Destination = arrData(1, ccDestination)
        .CoreSize = arrData(1, ccCoreSize)
        .EarthSize = arrData(1, ccEarthsize)
        .CoreConfig = arrData(1, cccoreconfig)
        .InsulationType = arrData(1, ccinsulationtype)
        .CableType = arrData(1, cccabletype)
        .CableLength = arrData(1, cccablelength)
    End With
    
    ' Return the populated cable object
    Set GetCableByRowIndex = cCable
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_Retreatment", "GetCableByRowIndex", Err.Number, Err.description, Erl
    Set GetCableByRowIndex = Nothing
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: UpdateCable
' PURPOSE: Updates an existing cable record in the table
' PARAMETERS: lngRowIndex - The row index in the ListRows collection (1-based)
'            cUpdatedCable - clCable object containing the updated cable data
' RETURNS: Boolean - True if update successful, False if failed
' NOTES: Replaces entire row with updated data from cable object
'------------------------------------------------------------------------------
Public Function UpdateCable(lngRowIndex As Long, cUpdatedCable As clCable) As Boolean
    On Error GoTo ErrorHandler
    
    ' Validate row index exists within table bounds
    If lngRowIndex < 1 Or lngRowIndex > Me.ListObjects("tbl_RetreatmentCables").ListRows.count Then
        MsgBox "Invalid row index: " & lngRowIndex, vbExclamation
        UpdateCable = False
        Exit Function
    End If
    
    ' Update the row with new cable data
    Dim arrRow As Variant
    arrRow = cUpdatedCable.ToRow()
    
    ' Write the updated data to the table row
    Me.ListObjects("tbl_RetreatmentCables").ListRows(lngRowIndex).Range.Value = arrRow
    
    ' Return success
    UpdateCable = True
    
ErrorExit:
Exit Function

ErrorHandler:
    HandleError "sht_Retreatment", "UpdateCable", Err.Number, Err.description, Erl
    UpdateCable = False
    Resume ErrorExit
End Function
-------------------------------------------------------------------------------
VBA MACRO Dashboard.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/Dashboard'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ===============================================================================
' CLASS MODULE: Dashboard (IMPROVED VERSION)
' Author: jorr@mtcarbine.com.au
' Date: 20-12-24
' Updated: [Current Date] - Enhanced with better error handling and validation
' Purpose: Worksheet class for Dashboard sheet - handles button initialization
' ===============================================================================

Option Explicit

' ===============================================================================
' SUBROUTINE: initialize (IMPROVED VERSION)
' PURPOSE: Sets up OnAction properties for shape-based buttons with validation
' NOTES: Enhanced with shape existence validation and better error handling
' CALLED FROM: Workbook initialization or sheet activation events
' ===============================================================================
Public Sub initialize()
    On Error GoTo AIError

    Debug.Print "Dashboard.initialize: Starting button initialization..."
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE CABLE REGISTRATION BUTTONS
    ' These buttons open the cable registration form for different plants
    ' -----------------------------------------------------------------------
    
    ' Initialize cable registration buttons using helper function
    Call InitializeCableButtons
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE ENDPOINT REGISTRATION BUTTONS
    ' These buttons open the endpoint registration form for different plants
    ' -----------------------------------------------------------------------
    
    ' Initialize endpoint registration buttons using helper function
    Call InitializeEndpointButtons
    
    Debug.Print "Dashboard.initialize: Button initialization completed successfully"

AIExit:
    Exit Sub

AIError:
    ' Handle any errors during button initialization
    HandleError "Dashboard", "initialize", Err.Number, Err.description, Erl
    Debug.Print "Dashboard.initialize: Initialization failed - " & Err.description
    Resume AIExit
End Sub

' ===============================================================================
' SUBROUTINE: InitializeCableButtons (NEW HELPER FUNCTION)
' PURPOSE: Initializes all cable registration buttons with validation
' NOTES: Separates cable button logic for better organization
' ===============================================================================
Private Sub InitializeCableButtons()
    On Error GoTo ErrorHandler
    
    Debug.Print "Dashboard.InitializeCableButtons: Setting up cable registration buttons..."
    
    ' -----------------------------------------------------------------------
    ' WET PLANT CABLE REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdNewWPCable") Then
        Me.Shapes("cmdNewWPCable").OnAction = "'ShowCableRegistrationForm ""WET_PLANT""'"
        Debug.Print "? Wet Plant cable button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdNewWPCable' not found on Dashboard"
    End If
    
    ' -----------------------------------------------------------------------
    ' ORE SORTER CABLE REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdNewOSCable") Then
        Me.Shapes("cmdNewOSCable").OnAction = "'ShowCableRegistrationForm ""ORE_SORTER""'"
        Debug.Print "? Ore Sorter cable button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdNewOSCable' not found on Dashboard"
    End If
    
    ' -----------------------------------------------------------------------
    ' RETREATMENT CABLE REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdNewGPCable") Then
        Me.Shapes("cmdNewGPCable").OnAction = "'ShowCableRegistrationForm ""RETREATMENT""'"
        Debug.Print "? Retreatment cable button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdNewGPCable' not found on Dashboard"
    End If
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "? Error in InitializeCableButtons: " & Err.description
    Err.Raise Err.Number, "Dashboard.InitializeCableButtons", Err.description
End Sub

' ===============================================================================
' SUBROUTINE: InitializeEndpointButtons (NEW HELPER FUNCTION)
' PURPOSE: Initializes all endpoint registration buttons with validation
' NOTES: Separates endpoint button logic for better organization
' ===============================================================================
Private Sub InitializeEndpointButtons()
    On Error GoTo ErrorHandler
    
    Debug.Print "Dashboard.InitializeEndpointButtons: Setting up endpoint registration buttons..."
    
    ' -----------------------------------------------------------------------
    ' WET PLANT ENDPOINT REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdEnterNewWetPlantEndpoint") Then
        Me.Shapes("cmdEnterNewWetPlantEndpoint").OnAction = "'ShowEndpointRegistrationForm ""WET_PLANT""'"
        Debug.Print "? Wet Plant endpoint button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdEnterNewWetPlantEndpoint' not found on Dashboard"
    End If
    
    ' -----------------------------------------------------------------------
    ' ORE SORTER ENDPOINT REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdNewOreSorterEndpoint") Then
        Me.Shapes("cmdNewOreSorterEndpoint").OnAction = "'ShowEndpointRegistrationForm ""ORE_SORTER""'"
        Debug.Print "? Ore Sorter endpoint button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdNewOreSorterEndpoint' not found on Dashboard"
    End If
    
    ' -----------------------------------------------------------------------
    ' RETREATMENT ENDPOINT REGISTRATION BUTTON
    ' -----------------------------------------------------------------------
    If ShapeExists("cmdNewRetreatmentEndpoint") Then
        Me.Shapes("cmdNewRetreatmentEndpoint").OnAction = "'ShowEndpointRegistrationForm ""RETREATMENT""'"
        Debug.Print "? Retreatment endpoint button initialized"
    Else
        Debug.Print "? Warning: Shape 'cmdNewRetreatmentEndpoint' not found on Dashboard"
    End If
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "? Error in InitializeEndpointButtons: " & Err.description
    Err.Raise Err.Number, "Dashboard.InitializeEndpointButtons", Err.description
End Sub

' ===============================================================================
' FUNCTION: ShapeExists (NEW UTILITY FUNCTION)
' PURPOSE: Checks if a shape exists on this worksheet before trying to access it
' PARAMETERS: shapeName - The name of the shape to check for
' RETURNS: Boolean - True if shape exists, False if not found
' NOTES: Prevents runtime errors from missing shapes
' ===============================================================================
Private Function ShapeExists(ByVal shapeName As String) As Boolean
    On Error GoTo ShapeNotFound
    
    ' -----------------------------------------------------------------------
    ' ATTEMPT TO ACCESS THE SHAPE
    ' If this succeeds, the shape exists
    ' -----------------------------------------------------------------------
    Dim testShape As Shape
    Set testShape = Me.Shapes(shapeName)
    
    ' If we reach this point, shape exists
    ShapeExists = True
    
CleanExit:
    ' Clean up object reference
    On Error Resume Next
    Set testShape = Nothing
    Exit Function
    
ShapeNotFound:
    ' Shape doesn't exist - return False
    ShapeExists = False
    Resume CleanExit
End Function

' ===============================================================================
' SUBROUTINE: ValidateAllButtons (NEW UTILITY FUNCTION)
' PURPOSE: Validates that all required shapes exist and procedures are callable
' NOTES: Can be called to verify dashboard setup without initializing
' ===============================================================================
Public Sub ValidateAllButtons()
    On Error GoTo ErrorHandler
    
    Debug.Print "Dashboard.ValidateAllButtons: Starting validation..."
    
    ' -----------------------------------------------------------------------
    ' DEFINE REQUIRED SHAPES AND THEIR PROCEDURES
    ' -----------------------------------------------------------------------
    Dim buttonData As Variant
    buttonData = Array( _
        Array("cmdNewWPCable", "ShowNewWPPowerCableForm_Click", "Wet Plant Cable"), _
        Array("cmdNewOSCable", "ShowNewOSPowerCableForm_Click", "Ore Sorter Cable"), _
        Array("cmdNewGPCable", "ShowNewGPPowerCableForm_Click", "Retreatment Cable"), _
        Array("cmdEnterNewWetPlantEndpoint", "ShowNewWPEndpointForm_Click", "Wet Plant Endpoint"), _
        Array("cmdNewOreSorterEndpoint", "ShowNewOSEndpointForm_Click", "Ore Sorter Endpoint"), _
        Array("cmdNewRetreatmentEndpoint", "ShowNewGPEndpointForm_Click", "Retreatment Endpoint") _
    )
    
    ' -----------------------------------------------------------------------
    ' VALIDATE EACH BUTTON
    ' -----------------------------------------------------------------------
    Dim i As Integer
    Dim allValid As Boolean
    allValid = True
    
    For i = LBound(buttonData) To UBound(buttonData)
        Dim shapeName As String, procedureName As String, description As String
        shapeName = buttonData(i)(0)
        procedureName = buttonData(i)(1)
        description = buttonData(i)(2)
        
        ' Check if shape exists
        If ShapeExists(shapeName) Then
            Debug.Print "? " & description & " button shape found: " & shapeName
        Else
            Debug.Print "? " & description & " button shape MISSING: " & shapeName
            allValid = False
        End If
        
        ' Note: Procedure existence checking would require more complex reflection
        ' For now, we'll assume procedures exist since you confirmed they do
    Next i
    
    ' -----------------------------------------------------------------------
    ' REPORT VALIDATION RESULTS
    ' -----------------------------------------------------------------------
    If allValid Then
        Debug.Print "? Dashboard validation PASSED - All required shapes found"
    Else
        Debug.Print "? Dashboard validation FAILED - Some shapes are missing"
    End If

ErrorHandler_Exit:
    Exit Sub
    
ErrorHandler:
    Debug.Print "? Error during dashboard validation: " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: ResetAllButtons (NEW UTILITY FUNCTION)
' PURPOSE: Clears OnAction properties for all dashboard buttons
' NOTES: Useful for debugging or reinitializing the dashboard
' ===============================================================================
Public Sub ResetAllButtons()
    On Error Resume Next ' Continue even if some shapes don't exist
    
    Debug.Print "Dashboard.ResetAllButtons: Clearing all button actions..."
    
    ' Clear cable registration buttons
    Me.Shapes("cmdNewWPCable").OnAction = ""
    Me.Shapes("cmdNewOSCable").OnAction = ""
    Me.Shapes("cmdNewGPCable").OnAction = ""
    
    ' Clear endpoint registration buttons
    Me.Shapes("cmdEnterNewWetPlantEndpoint").OnAction = ""
    Me.Shapes("cmdNewOreSorterEndpoint").OnAction = ""
    Me.Shapes("cmdNewRetreatmentEndpoint").OnAction = ""
    
    Debug.Print "Dashboard.ResetAllButtons: All button actions cleared"
End Sub

' ===============================================================================
' WORKSHEET EVENT HANDLERS (OPTIONAL ADDITIONS)
' ===============================================================================

' ===============================================================================
' EVENT: Worksheet_Activate
' PURPOSE: Automatically initialize buttons when Dashboard sheet is activated
' NOTES: Optional - ensures buttons are always properly set up
' ===============================================================================
Private Sub Worksheet_Activate()
    On Error GoTo ErrorHandler
    
    ' Automatically initialize buttons when sheet is activated
    Call Me.initialize
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "Error in Worksheet_Activate: " & Err.description
    ' Don't show user error for this - just log it
End Sub

' ===============================================================================
' DOCUMENTATION AND USAGE NOTES
' ===============================================================================
'
' IMPROVEMENTS MADE:
' 1. ? Added shape existence validation before assignment
' 2. ? Separated logic into helper functions for better organization
' 3. ? Enhanced error handling with detailed debug output
' 4. ? Added utility functions for validation and reset
' 5. ? Comprehensive logging for troubleshooting
' 6. ? Optional automatic initialization on sheet activation
'
' USAGE:
' - Call Dashboard.initialize() to set up all buttons
' - Call Dashboard.ValidateAllButtons() to check setup without initializing
' - Call Dashboard.ResetAllButtons() to clear all button actions
'
' DEBUGGING:
' - Check Immediate Window (Ctrl+G) for detailed initialization logs
' - All operations are logged with ?, ?, or ? status indicators
'
' EXTERNAL DEPENDENCIES:
' - HandleError() function (for consistent error handling)
' - 6 button click procedures in standard modules
'
' ===============================================================================

-------------------------------------------------------------------------------
VBA MACRO sht_Data.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/sht_Data'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: sht_Data (Worksheet Class Module)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Manages endpoint data for three plant types: Wet Plant, Ore Sorter,
'          and Retreatment Plant. Provides CRUD operations for endpoint records
'          stored in Excel tables with validation and error handling.
' ==============================================================================

Option Explicit

' ==============================================================================
' CONSTANTS - Regular Expression Patterns for Endpoint Short Name Validation
' ==============================================================================

' Wet Plant endpoint format: 2-3 letters + "1" + 2 digits (e.g., "AB101", "ABC101")
Private Const RE_WPEP_FORMAT As String = "^[A-Z]{2,3}[1][0-9]{2}$"

' Ore Sorter endpoint format: 2-3 letters + "2" + 2 digits (e.g., "AB201", "ABC201")
Private Const RE_OSEP_FORMAT As String = "^[A-Z]{2,3}[2][0-9]{2}$"

' Retreatment Plant endpoint format: 2-3 letters + "3" + 2 digits (e.g., "AB301", "ABC301")
Private Const RE_RPEP_FORMAT As String = "^[A-Z]{2,3}[3][0-9]{2}$"

' ==============================================================================
' ENUMERATIONS
' ==============================================================================

' Column positions for reading Wet Plant Endpoint data
' Note: This enum appears to be unused in the current code
Enum WPEreadColumns
    wrcWPEShortName = 12        ' Column 12 contains the short name
    wrcWPEDescription = wrcWPEShortName + 1  ' Column 13 contains the description
End Enum

' ==============================================================================
' PUBLIC FUNCTIONS
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: getNextEndpointRow
' PURPOSE: Returns the next available row number for adding a new endpoint
' PARAMETERS: strFormID - Identifies which plant type ("WET_PLANT", "ORE_SORTER", "RETREATMENT")
' RETURNS: Long - The row number where the next endpoint should be added
' NOTES: Calculates based on current count of rows in the respective table
'------------------------------------------------------------------------------
Public Function getNextEndpointRow(ByVal strFormID As String) As Long
    On Error GoTo ErrorHandler

    Dim strTableName As String
    
    ' Determine which table to work with based on the form ID
    If StrComp(strFormID, "WET_PLANT", vbTextCompare) = 0 Then
        strTableName = "tbl_WetPlantEndpoints"
        
    ElseIf StrComp(strFormID, "ORE_SORTER", vbTextCompare) = 0 Then
        strTableName = "tbl_OreSorterEndpoints"
        
    ElseIf StrComp(strFormID, "RETREATMENT", vbTextCompare) = 0 Then
        strTableName = "tbl_RetreatmentEndpoints"
    
    End If
    
    ' Return the count of existing rows plus 1 for the next available position
    getNextEndpointRow = Me.ListObjects(strTableName).ListRows.count + 1
    
done:
Exit Function

ErrorHandler:
    ' Comprehensive error handling with user notification and debug information
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error point: sht_Data.getNextEndpointRow"
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Resume Next allows the calling code to continue despite the error
    Resume Next
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetEndpointsArray - FIXED VERSION
' PURPOSE: Retrieves all endpoints for a specified plant type as an array of endpoint objects
' PARAMETERS: strFormID - Identifies which plant type to retrieve data from
' RETURNS: Variant - Array of clEndpoint objects containing all endpoints
' NOTES: Creates strongly-typed array of custom endpoint objects from table data
' FIXED: Removed invalid "As New" syntax from array declaration
'------------------------------------------------------------------------------
' ===============================================================================
' FIXED VERSION: GetEndpointsArray
' Replace the existing GetEndpointsArray function in sht_Data.cls with this code
' ===============================================================================

Public Function GetEndpointsArray(strFormID As String) As Variant
    On Error GoTo ErrorHandler
    
    Dim arrRows As Variant
    Dim strTableName As String
    Dim tbl As ListObject
    
    ' Determine which table to work with based on the form ID
    If StrComp(strFormID, "WET_PLANT", vbTextCompare) = 0 Then
        strTableName = "tbl_WetPlantEndpoints"
    ElseIf StrComp(strFormID, "ORE_SORTER", vbTextCompare) = 0 Then
        strTableName = "tbl_OreSorterEndpoints"
    ElseIf StrComp(strFormID, "RETREATMENT", vbTextCompare) = 0 Then
        strTableName = "tbl_RetreatmentEndpoints"
    Else
        ' Invalid FormID - return empty array
        GetEndpointsArray = Array()
        Exit Function
    End If
    
    ' Get table reference
    Set tbl = Me.ListObjects(strTableName)
    
    ' -----------------------------------------------------------------------
    ' HANDLE EMPTY TABLE CASE
    ' If table has no data rows, return empty array
    ' -----------------------------------------------------------------------
    If tbl.ListRows.count = 0 Then
        GetEndpointsArray = Array()
        Exit Function
    End If
    
    ' Get the raw data from the table
    arrRows = tbl.DataBodyRange.Value
    
    ' -----------------------------------------------------------------------
    ' HANDLE SINGLE ROW CASE
    ' DataBodyRange.Value returns different structures for 1 row vs multiple rows
    ' -----------------------------------------------------------------------
    Dim rowCount As Long
    If tbl.ListRows.count = 1 Then
        rowCount = 1
    Else
        rowCount = UBound(arrRows, 1)
    End If
    
    ' -----------------------------------------------------------------------
    ' CREATE ARRAY OF ENDPOINT OBJECTS
    ' Build array that can be properly returned as Variant
    ' -----------------------------------------------------------------------
    Dim arrEndpoints() As Variant
    ReDim arrEndpoints(1 To rowCount)
    
    Dim lngRow As Long
    Dim epTemp As clEndpoint
    
    ' Process each row of data
    For lngRow = 1 To rowCount
        ' Create new endpoint object
        Set epTemp = New clEndpoint
        
        ' Populate endpoint from array data
        If tbl.ListRows.count = 1 Then
            ' Single row case - arrRows is 1D
            epTemp.ShortName = arrRows(1)
            epTemp.description = arrRows(2)
        Else
            ' Multiple rows case - arrRows is 2D
            epTemp.ShortName = arrRows(lngRow, 1)
            epTemp.description = arrRows(lngRow, 2)
        End If
        
        ' Store in variant array
        Set arrEndpoints(lngRow) = epTemp
    Next lngRow
    
    ' Return the populated array
    GetEndpointsArray = arrEndpoints
    
    ' Clean up
    Set tbl = Nothing
    Set epTemp = Nothing
    
Exit Function

ErrorHandler:
    ' Error handling with proper cleanup
    MsgBox "An error occurred loading endpoints: " & Err.description, vbCritical
    Debug.Print "Error point: sht_Data.GetEndpointsArray"
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    Debug.Print "FormID: " & strFormID
    
    ' Return empty array on error
    GetEndpointsArray = Array()
    
    Set tbl = Nothing
    Set epTemp = Nothing
End Function


'------------------------------------------------------------------------------
' FUNCTION: SaveEndpoint
' PURPOSE: Validates and saves a new endpoint to the appropriate table
' PARAMETERS: strFormID - Plant type identifier (passed by reference)
'            epNewEndpoint - clEndpoint object containing the new endpoint data
' RETURNS: Boolean - True if save successful, False if validation fails
' NOTES: Performs format validation, duplicate checking, and adds to table
'------------------------------------------------------------------------------
Public Function SaveEndpoint(ByRef strFormID As String, epNewEndpoint As clEndpoint) As Boolean
    On Error GoTo ErrorHandler
    
    Dim strEndpointShortNamePattern As String
    Dim strTableName As String
    
    ' Determine validation pattern and table name based on plant type
    If StrComp(strFormID, "WET_PLANT", vbTextCompare) = 0 Then
        strEndpointShortNamePattern = RE_WPEP_FORMAT
        strTableName = "tbl_WetPlantEndpoints"
        
    ElseIf StrComp(strFormID, "ORE_SORTER", vbTextCompare) = 0 Then
        strEndpointShortNamePattern = RE_OSEP_FORMAT
        strTableName = "tbl_OreSorterEndpoints"
        
    ElseIf StrComp(strFormID, "RETREATMENT", vbTextCompare) = 0 Then
        strEndpointShortNamePattern = RE_RPEP_FORMAT
        strTableName = "tbl_RetreatmentEndpoints"
        
    End If
    
    ' Get existing endpoints for duplicate checking
    Dim arrEndpoints As Variant
    arrEndpoints = Me.GetEndpointsArray(strFormID)
    
    Dim rItem As Variant
    
    ' First validate the format of the short name using regex
    If MatchRegex(epNewEndpoint.ShortName, strEndpointShortNamePattern) Then
        ' Check for duplicates in both short name and description
        For Each rItem In arrEndpoints
        
            ' If either short name or description already exists, reject the new endpoint
            If StrComp(rItem.ShortName, epNewEndpoint.ShortName, vbTextCompare) = 0 _
                    Or StrComp(rItem.description, epNewEndpoint.description, vbTextCompare) = 0 Then
                    
                MsgBox "Endpoint name or Description already in use. Please try another.", vbOKOnly
                SaveEndpoint = False
                Exit Function
                
            End If
        Next rItem
        
    Else
        ' Short name format is invalid
        MsgBox "Please ensure short name has correct format."
        SaveEndpoint = False
        Exit Function
        
    End If
    
    ' Add new row to the appropriate table
    Dim lrNewRow As ListRow
    Set lrNewRow = Me.ListObjects(strTableName).ListRows.Add
    
    ' Populate the new row with endpoint data
    With lrNewRow
        .Range(1) = epNewEndpoint.ShortName    ' Column 1: Short Name
        .Range(2) = epNewEndpoint.description  ' Column 2: Description
        
    End With
        
    ' Get the row number of the newly added record
    Dim lngNewRowNumber As Long
    lngNewRowNumber = Me.ListObjects(strTableName).ListRows.count
    
    ' Return the new row number (converted to Boolean - any non-zero number = True)
    SaveEndpoint = lngNewRowNumber
    
    ' Clean up object references
    Set arrEndpoints = Nothing
                    
done:
Exit Function

ErrorHandler:
    ' Error handling with cleanup
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error point: sht_Data.SaveEndpoint"
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    Set arrEndpoints = Nothing
    Resume Next
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetEndpointTableName
' PURPOSE: Returns the table name associated with a given plant type
' PARAMETERS: strFormID - Plant type identifier
' RETURNS: String - The Excel table name for the specified plant type
' NOTES: Uses improved error handling with HandleError procedure
'------------------------------------------------------------------------------
Public Function GetEndpointTableName(ByVal strFormID As String) As String
On Error GoTo AIError

    ' Map form ID to corresponding table name
    If StrComp(strFormID, "WET_PLANT", vbTextCompare) = 0 Then
        GetEndpointTableName = "tbl_WetPlantEndpoints"
        
    ElseIf StrComp(strFormID, "ORE_SORTER", vbTextCompare) = 0 Then
        GetEndpointTableName = "tbl_OreSorterEndpoints"
        
    ElseIf StrComp(strFormID, "RETREATMENT", vbTextCompare) = 0 Then
        GetEndpointTableName = "tbl_RetreatmentEndpoints"
    
    End If
    
AIExit:
Exit Function

AIError:
    ' Uses external HandleError procedure for consistent error handling
    ' Erl returns the line number where the error occurred
    HandleError "sht_Data", "GetEndpointTableName", Err.Number, Err.description, Erl
    Resume AIExit
    
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetEndpointDescription
' PURPOSE: Retrieves the description for a specific endpoint by its short name
' PARAMETERS: strFormID - Plant type identifier
'            strShortName - The short name of the endpoint to find
' RETURNS: String - The description of the matching endpoint, empty if not found
' NOTES: Searches through all endpoints for the specified plant type
'------------------------------------------------------------------------------
Public Function GetEndpointDescription(ByVal strFormID As String, _
                    ByVal strShortName As String) As String
    On Error GoTo ErrorHandler

    ' Get all endpoints for the specified plant type
    Dim arrEndpoints As Variant
    arrEndpoints = Me.GetEndpointsArray(strFormID)
    
    Dim strResult As String  ' Will remain empty if no match found
    
    ' Search through all endpoints for a matching short name
    Dim epItem As Variant
    For Each epItem In arrEndpoints
        ' Case-insensitive comparison of short names
        If StrComp(epItem.ShortName, strShortName, vbTextCompare) = 0 Then
            strResult = epItem.description
            Exit For  ' Found match, no need to continue searching
            
        End If
    Next epItem
    
    ' Return the found description (or empty string if not found)
    GetEndpointDescription = strResult
    
    ' Clean up object references
    Set arrEndpoints = Nothing

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    Set arrEndpoints = Nothing
    HandleError "sht_Data", "GetEndpointDescription", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' SUBROUTINE: tester
' PURPOSE: Test/debug procedure to check table row count functionality
' NOTES: Development/testing code - appears to be for debugging purposes only
'       Uses improved error handling pattern with HandleError procedure
'------------------------------------------------------------------------------
Sub tester()
On Error GoTo AIError

    ' Test code to get count of rows in Wet Plant endpoints table
    Dim lngNewRowNumber As Long
    lngNewRowNumber = Me.ListObjects("tbl_WetPlantEndpoints").ListRows.count

AIExit:
Exit Sub

AIError:
    ' Uses external HandleError procedure for consistent error handling
    HandleError "sht_Data", "tester", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub


-------------------------------------------------------------------------------
VBA MACRO modDashCode.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/modDashCode'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
 ' ==============================================================================
' MODULE: modDashCode (Standard Module) - REFACTORED
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Dashboard interface module providing consolidated form launching
'          functionality. Simplified from 6 functions to 2 functions that
'          handle all plant types for both cable and endpoint registration.
' ==============================================================================

Option Explicit

' ==============================================================================
' PUBLIC SUBROUTINES - CONSOLIDATED FORM LAUNCHERS
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: ShowCableRegistrationForm
' PURPOSE: Launches the cable registration form for any plant type
' PARAMETERS: strFormID - Plant type identifier ("WET_PLANT", "ORE_SORTER", "RETREATMENT")
' NOTES: Replaces ShowNewWPPowerCableForm_Click, ShowNewOSPowerCableForm_Click,
'        and ShowNewGPPowerCableForm_Click with a single consolidated function
'------------------------------------------------------------------------------
Sub ShowCableRegistrationForm(strFormID As String)
On Error GoTo AIError

    ' Configure the cable registration form for the specified plant type
    frm_RegisterCable.txt_FormID.Value = strFormID
    
    ' Display the cable registration form modally
    frm_RegisterCable.Show

AIExit:
Exit Sub

AIError:
    ' Standardized error handling using HandleError procedure
    HandleError "modDashCode", "ShowCableRegistrationForm", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

'------------------------------------------------------------------------------
' SUBROUTINE: ShowEndpointRegistrationForm
' PURPOSE: Launches the endpoint registration form for any plant type
' PARAMETERS: strFormID - Plant type identifier ("WET_PLANT", "ORE_SORTER", "RETREATMENT")
' NOTES: Replaces ShowNewWPEndpointForm_Click, ShowNewOSEndpointForm_Click,
'        and ShowNewGPEndpointForm_Click with a single consolidated function
'------------------------------------------------------------------------------
Sub ShowEndpointRegistrationForm(strFormID As String)
On Error GoTo AIError

    ' Configure the endpoint registration form for the specified plant type
    frm_RegisterEndpoint.txt_FormID.Value = strFormID
    
    ' Display the endpoint registration form modally
    frm_RegisterEndpoint.Show

AIExit:
Exit Sub

AIError:
    ' Standardized error handling using HandleError procedure
    HandleError "modDashCode", "ShowEndpointRegistrationForm", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

' ==============================================================================
' USAGE EXAMPLES FOR DASHBOARD BUTTONS/SHAPES
' ==============================================================================
'
' Instead of having separate functions for each plant, you would now call:
'
' For Cable Registration:
' ShowCableRegistrationForm("WET_PLANT")      ' Wet Plant cables
' ShowCableRegistrationForm("ORE_SORTER")     ' Ore Sorter cables
' ShowCableRegistrationForm("RETREATMENT")    ' Retreatment cables
'
' For Endpoint Registration:
' ShowEndpointRegistrationForm("WET_PLANT")      ' Wet Plant endpoints
' ShowEndpointRegistrationForm("ORE_SORTER")     ' Ore Sorter endpoints
' ShowEndpointRegistrationForm("RETREATMENT")    ' Retreatment endpoints
'
' This can be called from:
' - Button click events
' - Shape click events
' - Menu selections
' - Other UI elements
'
' ==============================================================================
-------------------------------------------------------------------------------
VBA MACRO clCable.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/clCable'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' Author: jorr@mtcarbine.com.au
' Date 26-12-24
Option Explicit

Private mIsScheduled As Boolean
Private mIDAttached As Boolean
Private mCableID As String
Private mSource As String
Private mDestination As String
Private mCoreSize As String
Private mEarthSize As String
Private mCoreConfig As String
Private mInsulationType As String
Private mCableType As String
Private mCableLength As Integer

Public Enum eCableColumns
    ccScheduled = 1
    ccIDAttached = 2
    ccCableID = 3
    ccSource = 4
    ccDestination = 5
    ccCoreSize = 6
    ccEarthsize = 7
    cccoreconfig = 8
    ccinsulationtype = 9
    cccabletype = 10
    cccablelength = 11
    ccTotalColumns = 11
End Enum

Public Property Get Scheduled() As Boolean
On Error GoTo AIError

    Scheduled = mIsScheduled

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Scheduled", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let Scheduled(bIsScheduled As Boolean)
On Error GoTo AIError

    mIsScheduled = bIsScheduled

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Scheduled", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get IDAttached() As Boolean
On Error GoTo AIError

    IDAttached = mIDAttached

AIExit:
Exit Property

AIError:
    HandleError "clCable", "IDAttached", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let IDAttached(bIDAttached As Boolean)
On Error GoTo AIError

    mIDAttached = bIDAttached

AIExit:
Exit Property

AIError:
    HandleError "clCable", "IDAttached", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get cableID() As String
On Error GoTo AIError

    cableID = mCableID

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableID", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let cableID(sCableID As String)
On Error GoTo AIError

    mCableID = sCableID

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableID", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get Source() As String
On Error GoTo AIError

    Source = mSource

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Source", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let Source(sSource As String)
On Error GoTo AIError

    mSource = sSource

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Source", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get Destination() As String
On Error GoTo AIError

    Destination = mDestination

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Destination", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let Destination(sDestination As String)
On Error GoTo AIError

    mDestination = sDestination

AIExit:
Exit Property

AIError:
    HandleError "clCable", "Destination", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get CoreSize() As String
On Error GoTo AIError

    CoreSize = mCoreSize

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CoreSize", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let CoreSize(sCoreSize As String)
On Error GoTo AIError

    mCoreSize = sCoreSize

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CoreSize", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get EarthSize() As String
On Error GoTo AIError

    EarthSize = mEarthSize

AIExit:
Exit Property

AIError:
    HandleError "clCable", "EarthSize", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let EarthSize(sEarthSize As String)
On Error GoTo AIError

    mEarthSize = sEarthSize

AIExit:
Exit Property

AIError:
    HandleError "clCable", "EarthSize", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get CoreConfig() As String
On Error GoTo AIError

    CoreConfig = mCoreConfig

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CoreConfig", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let CoreConfig(sCoreConfig As String)
On Error GoTo AIError

    mCoreConfig = sCoreConfig

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CoreConfig", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get InsulationType() As String
On Error GoTo AIError

    InsulationType = mInsulationType

AIExit:
Exit Property

AIError:
    HandleError "clCable", "InsulationType", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let InsulationType(sInsulationType As String)
On Error GoTo AIError

    mInsulationType = sInsulationType

AIExit:
Exit Property

AIError:
    HandleError "clCable", "InsulationType", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get CableType() As String
On Error GoTo AIError

    CableType = mCableType

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableType", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let CableType(sCableType As String)
On Error GoTo AIError

    mCableType = sCableType

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableType", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get CableLength() As Integer
On Error GoTo AIError

    CableLength = mCableLength

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableLength", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let CableLength(iCableLength As Integer)
On Error GoTo AIError

    mCableLength = iCableLength

AIExit:
Exit Property

AIError:
    HandleError "clCable", "CableLength", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Function ToRow() As Variant
    On Error GoTo ErrorHandler
    
    Dim arrRow As Variant
    ReDim arrRow(1 To 11)
    
    Dim lngRow As Long
    For lngRow = 1 To ccTotalColumns
        If lngRow = ccScheduled Then
            arrRow(lngRow) = mIsScheduled
            
        ElseIf lngRow = ccIDAttached Then
            arrRow(lngRow) = mIDAttached
        
        ElseIf lngRow = ccCableID Then
            arrRow(lngRow) = mCableID
                    
        ElseIf lngRow = ccSource Then
            arrRow(lngRow) = mSource
                    
        ElseIf lngRow = ccDestination Then
            arrRow(lngRow) = mDestination
                    
        ElseIf lngRow = ccCoreSize Then
            arrRow(lngRow) = mCoreSize
                    
        ElseIf lngRow = ccEarthsize Then
            arrRow(lngRow) = mEarthSize
                    
        ElseIf lngRow = cccoreconfig Then
            arrRow(lngRow) = mCoreConfig
                    
        ElseIf lngRow = ccinsulationtype Then
            arrRow(lngRow) = mInsulationType
                    
        ElseIf lngRow = cccabletype Then
            arrRow(lngRow) = mCableType
                    
        ElseIf lngRow = cccablelength Then
            arrRow(lngRow) = mCableLength
            
        End If
    Next lngRow
    
    ToRow = arrRow
    
done:
Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error point: sht_WetPlant.SaveCable"
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next
End Function

-------------------------------------------------------------------------------
VBA MACRO modUtils.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/modUtils'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' Author: jorr@mtcarbine.com.au
' Date 25-12-24
Option Explicit

Function AttBox(prompt As String, _
            Optional buttons As VbMsgBoxStyle = vbOKOnly, _
            Optional title As String = "") As VbMsgBoxStyle
On Error GoTo AIError
            
#If Debugging = 0 Then
    MsgBox prompt, buttons, title
#End If


AIExit:
Exit Function

AIError:
    HandleError "modUtils", "AttBox", Err.Number, Err.description, Erl
    Resume AIExit
    
End Function

Public Function RemoveChar(strInput As String, strChar As String) As String
    On Error GoTo ErrorHandler
    
    'to remove all occurrences of strChar from strInput string
    RemoveChar = Replace(strInput, strChar, "")
    
done:
Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next

End Function

Public Function RegexReplace(strOriginalText As String, _
                      strPatternText As String, _
                      strReplacementText As String, _
                      Optional bIgnoreCase As Boolean = False) As String
    On Error GoTo ErrorHandler

    Dim objRegExp As Object
    Set objRegExp = CreateObject("vbscript.regexp")

    objRegExp.IgnoreCase = bIgnoreCase
    objRegExp.Pattern = strPatternText
    objRegExp.Global = True
    RegexReplace = objRegExp.Replace(strOriginalText, strReplacementText)

done:
Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next

End Function

Public Function MatchRegex(strTestString As String, _
                    strPattern As String, _
                    Optional bIgnoreCase As Boolean = True) As Boolean
    On Error GoTo ErrorHandler
    
    Dim objRegExp As Object
    Set objRegExp = CreateObject("vbscript.regexp")

    objRegExp.IgnoreCase = bIgnoreCase
    objRegExp.Pattern = strPattern
    objRegExp.Global = False
    MatchRegex = objRegExp.test(strTestString)
    
    ' Exit function to avoid running the error handler code if no errors occurred
    Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next

End Function

Public Function CountElements(arrTest As Variant) As Long
    On Error GoTo ErrorHandler
    
    Dim varItem As Variant
    Dim lngCounter As Long
    
    lngCounter = 0
    
    For Each varItem In arrTest
        lngCounter = lngCounter + 1
    Next
    
    CountElements = lngCounter

    ' Exit function to avoid running the error handler code if no errors occurred
    Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next

End Function

Public Function RangeToCables(arrRows() As Variant) As clCable
    On Error GoTo ErrorHandler

    Dim arrCables() As clCable
    ReDim arrCables(1 To UBound(arrRows, 1))
    
    Dim lngRow As Long, lngCol As Long
    
    For lngRow = 1 To UBound(arrRows, 1)
        For lngCol = 1 To UBound(arrRows, 2)
            If lngCol = eCableColumns.ccScheduled Then
                arrCables(lngRow).Scheduled = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccIDAttached Then
                arrCables(lngRow).IDAttached = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCableID Then
                arrCables(lngRow).cableID = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccSource Then
                arrCables(lngRow).Source = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccDestination Then
                arrCables(lngRow).Destination = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccCoreSize Then
                arrCables(lngRow).CoreSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccEarthsize Then
                arrCables(lngRow).EarthSize = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccoreconfig Then
                arrCables(lngRow).CoreConfig = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = ccinsulationtype Then
                arrCables(lngRow).InsulationType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccabletype Then
                arrCables(lngRow).CableType = arrRows(lngRow, lngCol)
                
            ElseIf lngCol = cccablelength Then
                arrCables(lngRow).CableLength = arrRows(lngRow, lngCol)
                
            End If
        
        Next lngCol
    Next lngRow
        
    RangeToCables = arrCables
    
' Exit function to avoid running the error handler code if no errors occurred
Exit Function

ErrorHandler:
    ' Error handling code
    MsgBox "An error occurred: " & Err.description, vbCritical
    Debug.Print "Error Number: " & Err.Number
    Debug.Print "Error Description: " & Err.description
    
    ' Clean up (if applicable)
    ' You can add any cleanup code here if needed

    ' Resume the next statement to continue running the code
    Resume Next
End Function

-------------------------------------------------------------------------------
VBA MACRO frm_RegisterCable.frm 
in file: xl/vbaProject.bin - OLE stream: 'VBA/frm_RegisterCable'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ===============================================================================
' COMPLETE VBA FORM CODE: frm_RegisterCable
' Author: jorr@mtcarbine.com.au
' Date: 20-12-24
' Updated: [Current Date] - FIXED: Double-click combobox issue
' Purpose: Cable registration form for MCO Power Cable Register system
' ===============================================================================

Option Explicit

' ===============================================================================
' MODULE-LEVEL VARIABLES
' ===============================================================================
' Form identifier - indicates which plant this form instance is configured for
' Possible values: "WET_PLANT", "ORE_SORTER", "RETREATMENT"
Dim ID_NEW_CAB_FORM As String

' Regular expression patterns for validation - set by UserForm_Activate based on plant type
Dim strShortNamePattern As String    ' Pattern for source/destination endpoint names
Dim strCircuitNamePattern As String  ' Pattern for circuit name format
Dim strCableIDPattern As String      ' Pattern for complete cable ID format

' General purpose counter variable
Dim count As Integer

' Form mode tracking - indicates whether form is in CREATE or UPDATE mode
Dim FormMode As String  ' Values: "CREATE" or "UPDATE"

' Row index for update operations - stores which row we're editing
Dim UpdateRowIndex As Long

' ===============================================================================
' MODULE-LEVEL VARIABLES
' ===============================================================================
'Dim ID_NEW_CAB_FORM As String
'Dim strShortNamePattern As String
'Dim strCircuitNamePattern As String
'Dim strCableIDPattern As String
'Dim count As Integer

' ===============================================================================
' BUTTON EVENT HANDLERS
' ===============================================================================

' ===============================================================================
' SUBROUTINE: cmd_AddEndpoint_Click
' PURPOSE: Opens the endpoint registration form for adding new endpoints
' NOTES: Passes current form ID to endpoint form for proper plant association
' ===============================================================================
Private Sub cmd_AddEndpoint_Click()
    On Error GoTo ErrorHandler

    ' -----------------------------------------------------------------------
    ' PREPARE AND SHOW ENDPOINT REGISTRATION FORM
    ' Pass the current form ID so new endpoint gets added to correct plant
    ' -----------------------------------------------------------------------
    frm_RegisterEndpoint.txt_FormID.Value = Me.txt_FormID  ' Pass plant identifier
    frm_RegisterEndpoint.Show                              ' Display endpoint form
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors opening endpoint form
    MsgBox "An error occurred opening endpoint form: " & Err.description, vbCritical, "Form Error"
    Debug.Print "Error in cmd_AddEndpoint_Click: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: cmd_Schedule_Click
' PURPOSE: Placeholder for scheduling functionality (not yet implemented)
' NOTES: Future enhancement - will integrate with SharePoint for cable scheduling
' ===============================================================================
Private Sub cmd_Schedule_Click()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' NOTIFY USER THAT FEATURE IS NOT YET AVAILABLE
    ' -----------------------------------------------------------------------
    MsgBox "This functionality has not yet been implemented. Please try again later.", _
           vbInformation, "Feature Not Available"
    
    ' -----------------------------------------------------------------------
    ' FUTURE IMPLEMENTATION PLACEHOLDER
    ' When ready, this will integrate with SharePoint for cable scheduling
    ' -----------------------------------------------------------------------
    ' TODO: Implement SharePoint integration
    ' Call modSharepoint.PostSchedule()
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during schedule operation
    MsgBox "An error occurred with scheduling: " & Err.description, vbCritical, "Schedule Error"
    Debug.Print "Error in cmd_Schedule_Click: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: cmd_Save_Click
' PURPOSE: Validates form data, creates cable object, saves to database, closes form
' NOTES: This is the "Save and Close" button - saves data then exits form
' ===============================================================================
Private Sub cmd_Save_Click()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' VALIDATE ALL REQUIRED FIELDS BEFORE PROCEEDING
    ' -----------------------------------------------------------------------
    If Not Me.ValidateRequired() Then
        ' Validation failed - ValidateRequired() already showed error message
        ' and set focus to problem field, so just exit
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' CREATE CABLE OBJECT FROM FORM DATA
    ' -----------------------------------------------------------------------
    Dim cNewCable As New clCable
    Set cNewCable = Me.GetNewCable()
    
    ' Check if cable object creation was successful
    If cNewCable Is Nothing Then
        MsgBox "Failed to create cable object. Please check your data and try again.", vbCritical, "Save Error"
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' SAVE OR UPDATE CABLE BASED ON FORM MODE
    ' -----------------------------------------------------------------------
    Dim bSuccess As Boolean
    
    If FormMode = "UPDATE" Then
        ' UPDATE MODE: Update existing cable
        bSuccess = modDatabase.UpdateCable(ID_NEW_CAB_FORM, UpdateRowIndex, cNewCable)
        
        If bSuccess Then
            MsgBox "Cable updated successfully!", vbInformation, "Update Successful"
            Unload Me
        Else
            MsgBox "An error occurred updating the cable. Please check your data and try again.", vbCritical, "Update Error"
        End If
        
    Else
        ' CREATE MODE: Register new cable
        bSuccess = modDatabase.RegisterCable(ID_NEW_CAB_FORM, cNewCable)
        
        If bSuccess Then
            MsgBox "New cable entered successfully!", vbInformation, "Save Successful"
            Unload Me
        Else
            MsgBox "An error occurred saving the cable. Please check your data and try again.", vbCritical, "Save Error"
        End If
    End If

ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during save operation
    MsgBox "An error occurred during save: " & Err.description, vbCritical, "Save Error"
    Debug.Print "Error in cmd_Save_Click: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: cmd_SaveContinue_Click
' PURPOSE: Validates, saves cable data, then resets form for next entry
' NOTES: This is "Save and Continue" - saves data but keeps form open for more entries
' ===============================================================================
Private Sub cmd_SaveContinue_Click()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' IN UPDATE MODE, "SAVE & CONTINUE" DOESN'T MAKE SENSE
    ' Redirect to regular save behavior
    ' -----------------------------------------------------------------------
    If FormMode = "UPDATE" Then
        cmd_Save_Click
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE ALL REQUIRED FIELDS BEFORE PROCEEDING
    ' -----------------------------------------------------------------------
    If Not Me.ValidateRequired() Then
        ' Validation failed - ValidateRequired() already showed error message
        ' and set focus to problem field, so just exit
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' CREATE CABLE OBJECT FROM FORM DATA
    ' -----------------------------------------------------------------------
    Dim cNewCable As New clCable
    Set cNewCable = Me.GetNewCable()
    
    ' Check if cable object creation was successful
    If cNewCable Is Nothing Then
        MsgBox "Failed to create cable object. Please check your data and try again.", vbCritical, "Save Error"
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' ATTEMPT TO SAVE CABLE TO DATABASE
    ' -----------------------------------------------------------------------
    If modDatabase.RegisterCable(ID_NEW_CAB_FORM, cNewCable) Then
        ' SUCCESS: Cable saved successfully
        MsgBox "Cable saved! You can now enter another cable.", vbInformation, "Save Successful"
        
        ' -----------------------------------------------------------------------
        ' RESET FORM FOR NEXT CABLE ENTRY
        ' Refresh endpoint dropdowns in case new endpoints were added
        ' -----------------------------------------------------------------------
        Me.ReloadForm
        Me.UpdateComboBox sht_Data.GetEndpointTableName(Me.txt_FormID)
        
    Else
        ' FAILURE: Database save operation failed
        MsgBox "An error occurred saving the cable. Please check your data and try again.", vbCritical, "Save Error"
    End If

ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during save operation
    MsgBox "An error occurred during save: " & Err.description, vbCritical, "Save Error"
    Debug.Print "Error in cmd_SaveContinue_Click: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: cmd_Cancel_Click
' PURPOSE: Closes the form without saving any changes
' NOTES: Simple unload operation, no validation or confirmation required
' ===============================================================================
Private Sub cmd_Cancel_Click()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' CLOSE FORM WITHOUT SAVING
    ' -----------------------------------------------------------------------
    Unload Me
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during cancel operation
    MsgBox "An error occurred closing the form: " & Err.description, vbCritical, "Form Error"
    Debug.Print "Error in cmd_Cancel_Click: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' TEXT FIELD EVENT HANDLERS
' ===============================================================================

' ===============================================================================
' SUBROUTINE: txt_CableID_GotFocus
' PURPOSE: Selects all text in Cable ID field when user tabs into it
' NOTES: User convenience - makes it easy to replace the entire cable ID
' ===============================================================================
Private Sub txt_CableID_GotFocus()
    On Error Resume Next
    
    ' -----------------------------------------------------------------------
    ' SELECT ALL TEXT FOR EASY REPLACEMENT
    ' -----------------------------------------------------------------------
    With Me.txt_CableID
        .SelStart = 0                   ' Start selection at beginning
        .SelLength = Len(.Value)        ' Select all characters
    End With
End Sub

' ===============================================================================
' SUBROUTINE: txt_CableID_Change
' PURPOSE: Validates Cable ID format using regex pattern and updates UI colors
' NOTES: Enhanced with better commenting and comprehensive validation
' ===============================================================================
Private Sub txt_CableID_Change()
    On Error GoTo CleanFail
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE VARIABLES AND GET CURRENT VALUES
    ' -----------------------------------------------------------------------
    Dim re As Object          ' Regular expression object for pattern matching
    Dim pat As String         ' Pattern string for validation
    Dim cid As String         ' Current cable ID value
    
    ' Get current cable ID value and ensure it's a string (handle Null values)
    cid = CStr(txt_CableID.Value & vbNullString)

    ' -----------------------------------------------------------------------
    ' HANDLE EMPTY CABLE ID
    ' If field is empty, set to pink and exit
    ' -----------------------------------------------------------------------
    If Len(cid) = 0 Then
        txt_CableID.ForeColor = RGB(255, 192, 203)  ' PINK - Required field empty
        GoTo CleanExit
    End If

    ' -----------------------------------------------------------------------
    ' SET UP REGULAR EXPRESSION PATTERN FOR CABLE ID VALIDATION
    ' Pattern should match: SOURCE-CIRCUIT-DESTINATION format
    ' Example: WM101-C1001-CV102
    ' -----------------------------------------------------------------------
    pat = strCableIDPattern
    ' Use default pattern if none specified: alphanumeric with hyphens
    If Len(pat & vbNullString) = 0 Then pat = "^[A-Za-z0-9\-]{1,100}$"
    
    ' Create and configure regex object
    Set re = CreateObject("VBScript.RegExp")
    re.Pattern = pat
    re.IgnoreCase = True

    ' -----------------------------------------------------------------------
    ' VALIDATE CABLE ID AND UPDATE UI ACCORDINGLY
    ' -----------------------------------------------------------------------
    If re.test(cid) Then
        ' VALIDATION PASSED: Cable ID format matches expected pattern
        txt_CableID.ForeColor = RGB(0, 255, 0)      ' GREEN - Valid format
    Else
        ' VALIDATION FAILED: Cable ID doesn't match expected pattern
        txt_CableID.ForeColor = RGB(255, 192, 203)  ' PINK - Invalid format
    End If

CleanExit:
    ' -----------------------------------------------------------------------
    ' CLEANUP AND EXIT
    ' -----------------------------------------------------------------------
    On Error Resume Next
    Set re = Nothing
    Exit Sub

CleanFail:
    ' Handle any unexpected errors during validation
    HandleError "frm_RegisterCable", "txt_CableID_Change", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' SUBROUTINE: txt_Length_KeyPress
' PURPOSE: Restricts cable length input to numeric values and decimal point only
' PARAMETERS: KeyAscii - ASCII value of pressed key (passed by reference)
' NOTES: FIXED - Now allows decimal point, backspace, and proper numeric input
' ===============================================================================
Private Sub txt_Length_KeyPress(ByVal KeyAscii As MSForms.ReturnInteger)
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' ALLOW CONTROL KEYS (Backspace, Delete, etc.)
    ' ASCII 8 = Backspace
    ' -----------------------------------------------------------------------
    If KeyAscii = 8 Then Exit Sub
    
    ' -----------------------------------------------------------------------
    ' ALLOW DECIMAL POINT (only one allowed)
    ' ASCII 46 = decimal point "."
    ' -----------------------------------------------------------------------
    If KeyAscii = 46 Then
        ' Check if decimal point already exists in the text
        If InStr(Me.txt_Length.Value, ".") > 0 Then
            ' Decimal point already exists - reject this keypress
            KeyAscii = 0
        End If
        Exit Sub
    End If
    
    ' -----------------------------------------------------------------------
    ' ALLOW NUMERIC DIGITS ONLY (0-9)
    ' ASCII 48-57 = digits "0" through "9"
    ' -----------------------------------------------------------------------
    If KeyAscii < 48 Or KeyAscii > 57 Then
        ' Not a digit - reject this keypress
        KeyAscii = 0
    End If
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during key press validation
    Debug.Print "Error in txt_Length_KeyPress: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: txt_CircuitName_Change
' PURPOSE: Validates circuit name format and updates cable ID when valid
' NOTES: Enhanced with better commenting and comprehensive validation
' ===============================================================================
Private Sub txt_CircuitName_Change()
    On Error GoTo CleanFail
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE VARIABLES AND GET CURRENT VALUES
    ' -----------------------------------------------------------------------
    Dim re As Object          ' Regular expression object for pattern matching
    Dim pat As String         ' Pattern string for validation
    Dim src As String         ' Current source value
    Dim cir As String         ' Current circuit name value
    
    ' Get current values and ensure they're strings (handle Null values)
    src = CStr(cmb_Source.Value & vbNullString)
    cir = CStr(txt_CircuitName.Value & vbNullString)

    ' -----------------------------------------------------------------------
    ' HANDLE EMPTY CIRCUIT NAME
    ' If field is empty or source is not set, disable destination and exit
    ' -----------------------------------------------------------------------
    If Len(cir) = 0 Or Len(src) = 0 Then
        txt_CircuitName.ForeColor = RGB(255, 192, 203)  ' PINK - Required field
        cmb_Destination.Enabled = False
        GoTo CleanExit
    End If

    ' -----------------------------------------------------------------------
    ' SET UP REGULAR EXPRESSION PATTERN FOR CIRCUIT NAME VALIDATION
    ' Pattern should match: Cxxxx format (e.g., C1001, C2001, C3001)
    ' -----------------------------------------------------------------------
    pat = strCircuitNamePattern
    ' Use default pattern if none specified: C followed by digits
    If Len(pat & vbNullString) = 0 Then pat = "^[CP][0-9]{1,10}$"
    
    ' Create and configure regex object
    Set re = CreateObject("VBScript.RegExp")
    re.Pattern = pat
    re.IgnoreCase = True

    ' -----------------------------------------------------------------------
    ' VALIDATE CIRCUIT NAME AND UPDATE UI ACCORDINGLY
    ' -----------------------------------------------------------------------
    If re.test(cir) Then
        ' VALIDATION PASSED: Circuit name format is valid
        txt_CircuitName.ForeColor = RGB(0, 255, 0)      ' GREEN - Valid format
        
        ' Enable destination dropdown since source and circuit are both valid
        cmb_Destination.Enabled = True
        
        ' Update Cable ID with source and circuit (destination will be added when selected)
        txt_CableID.Value = src & "-" & cir
        
    Else
        ' VALIDATION FAILED: Circuit name doesn't match expected pattern
        txt_CircuitName.ForeColor = RGB(255, 192, 203)  ' PINK - Invalid format
        cmb_Destination.Enabled = False
    End If

CleanExit:
    ' -----------------------------------------------------------------------
    ' CLEANUP AND EXIT
    ' -----------------------------------------------------------------------
    On Error Resume Next
    Set re = Nothing
    Exit Sub

CleanFail:
    ' Handle any unexpected errors during validation
    HandleError "frm_RegisterCable", "txt_CircuitName_Change", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' COMBOBOX EVENT HANDLERS
' ===============================================================================

' ===============================================================================
' SUBROUTINE: cmb_Source_Change
' PURPOSE: Validates source selection and enables destination when valid
' NOTES: FIXED - Now works with both Change and Click events for immediate response
' ===============================================================================
Private Sub cmb_Source_Change()
    On Error GoTo CleanFail
    
    ' Call the common validation routine
    ValidateSourceSelection
    
CleanExit:
    Exit Sub
    
CleanFail:
    HandleError "frm_RegisterCable", "cmb_Source_Change", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' SUBROUTINE: cmb_Source_Click
' PURPOSE: Handles immediate click event on source combobox
' NOTES: ADDED - This fixes the double-click issue by responding to Click event
' ===============================================================================
Private Sub cmb_Source_Click()
    On Error GoTo CleanFail
    
    ' Call the common validation routine
    ValidateSourceSelection
    
CleanExit:
    Exit Sub
    
CleanFail:
    HandleError "frm_RegisterCable", "cmb_Source_Click", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' SUBROUTINE: ValidateSourceSelection (HELPER FUNCTION)
' PURPOSE: Common validation logic for source selection (used by both Change and Click)
' NOTES: NEW - Centralizes validation logic to avoid code duplication
' ===============================================================================
Private Sub ValidateSourceSelection()
    On Error GoTo CleanFail

    Dim re As Object
    Dim pat As String
    Dim src As String
    
    ' Get current source value
    src = CStr(cmb_Source.Value & vbNullString)

    ' -----------------------------------------------------------------------
    ' HANDLE EMPTY SOURCE
    ' -----------------------------------------------------------------------
    If Len(src) = 0 Then
        cmb_Source.ForeColor = RGB(255, 192, 203)   ' PINK - No selection
        txt_CircuitName.Enabled = False
        cmb_Destination.Enabled = False
        GoTo CleanExit
    End If

    ' -----------------------------------------------------------------------
    ' VALIDATE SOURCE FORMAT USING REGEX
    ' -----------------------------------------------------------------------
    pat = strShortNamePattern
    If Len(pat & vbNullString) = 0 Then pat = "^[A-Za-z0-9_\-\s]{1,50}$"
    Set re = CreateObject("VBScript.RegExp")
    re.Pattern = pat
    re.IgnoreCase = True

    ' -----------------------------------------------------------------------
    ' UPDATE UI BASED ON VALIDATION RESULT
    ' -----------------------------------------------------------------------
    If re.test(src) Then
        ' VALIDATION PASSED
        txt_CableID.Value = src
        cmb_Source.ForeColor = RGB(0, 255, 0)       ' GREEN - Valid selection
        txt_CircuitName.Enabled = True
        cmb_Destination.Enabled = True              ' Enable destination immediately
        
        ' Auto-generate circuit number if not already set
        If Len(CStr(txt_CircuitName.Value & vbNullString)) = 0 Then
            txt_CircuitName.Value = "C" & modDatabase.GetNextCircuitNumber(ID_NEW_CAB_FORM)
        End If
    Else
        ' VALIDATION FAILED
        cmb_Source.ForeColor = RGB(255, 192, 203)   ' PINK - Invalid format
        txt_CircuitName.Enabled = False
        cmb_Destination.Enabled = False
    End If

CleanExit:
    On Error Resume Next
    Set re = Nothing
    Exit Sub
    
CleanFail:
    HandleError "frm_RegisterCable", "ValidateSourceSelection", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' SUBROUTINE: cmb_Destination_Change
' PURPOSE: Validates destination selection and updates cable ID when valid
' NOTES: Enhanced with better color coding and comprehensive validation
' ===============================================================================
Private Sub cmb_Destination_Change()
    On Error GoTo CleanFail
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE VARIABLES AND GET CURRENT VALUES
    ' -----------------------------------------------------------------------
    Dim re As Object          ' Regular expression object for pattern matching
    Dim pat As String         ' Pattern string for validation
    Dim dest As String        ' Current destination value
    Dim src As String         ' Current source value
    Dim cir As String         ' Current circuit name value
    
    ' Get current values and ensure they're strings (handle Null values)
    dest = CStr(cmb_Destination.Value & vbNullString)
    src = CStr(cmb_Source.Value & vbNullString)
    cir = CStr(txt_CircuitName.Value & vbNullString)

    ' -----------------------------------------------------------------------
    ' SET UP REGULAR EXPRESSION PATTERN FOR DESTINATION VALIDATION
    ' -----------------------------------------------------------------------
    pat = strShortNamePattern
    ' Use default pattern if none specified: alphanumeric with limited special chars
    If Len(pat & vbNullString) = 0 Then pat = "^[A-Za-z0-9_\-\s]{1,50}$"
    
    ' Create and configure regex object
    Set re = CreateObject("VBScript.RegExp")
    re.Pattern = pat
    re.IgnoreCase = True

    ' -----------------------------------------------------------------------
    ' VALIDATE DESTINATION AND UPDATE UI ACCORDINGLY
    ' -----------------------------------------------------------------------
    If re.test(dest) Then
        ' VALIDATION PASSED: Destination format is valid
        cmb_Destination.ForeColor = RGB(0, 255, 0)     ' GREEN - Valid input
        
        ' Update Cable ID if all required components are available
        If Len(src) > 0 And Len(cir) > 0 Then
            ' All three components available: Source-Circuit-Destination
            txt_CableID.Value = src & "-" & cir & "-" & dest
        End If
        
    Else
        ' VALIDATION FAILED: Destination format is invalid or empty
        If Len(dest) > 0 Then
            ' Has content but invalid format
            cmb_Destination.ForeColor = RGB(255, 192, 203)  ' PINK - Invalid format
        Else
            ' Empty field - neutral state
            cmb_Destination.ForeColor = RGB(0, 0, 0)        ' BLACK - No selection yet
        End If
    End If

CleanExit:
    ' -----------------------------------------------------------------------
    ' CLEANUP AND EXIT
    ' -----------------------------------------------------------------------
    On Error Resume Next
    Set re = Nothing
    Exit Sub

CleanFail:
    ' Handle any unexpected errors during validation
    HandleError "frm_RegisterCable", "cmb_Destination_Change", Err.Number, Err.description, Erl
    Resume CleanExit
End Sub

' ===============================================================================
' FORM LIFECYCLE EVENT HANDLERS
' ===============================================================================

' ===============================================================================
' SUBROUTINE: UserForm_Initialize
' PURPOSE: Runs when form object is first created, before it's shown
' NOTES: Sets up initial form state - all fields empty and disabled
' ===============================================================================
Private Sub UserForm_Initialize()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE FORM TO EMPTY STATE
    ' Call ReloadForm to set all controls to their initial state
    ' -----------------------------------------------------------------------
    Me.ReloadForm
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during form initialization
    MsgBox "An error occurred initializing the form: " & Err.description, vbCritical, "Initialization Error"
    Debug.Print "Error in UserForm_Initialize: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: UserForm_Activate
' PURPOSE: Runs every time the form becomes the active window
' NOTES: Configures plant-specific settings, theming, and validation patterns
' ===============================================================================
' ===============================================================================
' SUBROUTINE: UserForm_Activate
' PURPOSE: Runs every time the form becomes the active window
' NOTES: Configures plant-specific settings, theming, and validation patterns
' ===============================================================================
Private Sub UserForm_Activate()
    On Error GoTo ErrorHandler
    
    ' -----------------------------------------------------------------------
    ' INITIALIZE FORM MODE IF NOT ALREADY SET
    ' Default to CREATE mode if not specified (for backwards compatibility)
    ' -----------------------------------------------------------------------
    If FormMode = "" Then
        FormMode = "CREATE"
    End If
    
    ' -----------------------------------------------------------------------
    ' GET FORM IDENTIFIER TO DETERMINE PLANT TYPE
    ' -----------------------------------------------------------------------
    ID_NEW_CAB_FORM = Me.txt_FormID.Value
    
    ' -----------------------------------------------------------------------
    ' CONFIGURE FORM BASED ON PLANT TYPE
    ' Sets validation patterns and form title
    ' -----------------------------------------------------------------------
    Select Case ID_NEW_CAB_FORM
        Case Is = "WET_PLANT"
            ' Set form title based on mode
            Me.caption = IIf(FormMode = "CREATE", "Register New Cable - Wet Screen Crushing Plant", "Edit Cable - Wet Screen Crushing Plant")
            
            ' Set validation patterns for Wet Plant (plant identifier "1")
            strShortNamePattern = "^[A-Z]{2,3}[1][0-1][0-9]$"      ' e.g., WM101, CV102
            strCircuitNamePattern = "^[C][1][0-9]{3}$"            ' e.g., C1001
            strCableIDPattern = "^[A-Z]{2,3}[1][01][0-9][-][C][1][0-9]{3}[-][A-Z]{2,3}[1][01][0-9]$"
            
            ' Apply dark blue theming
            Me.BackColor = RGB(31, 78, 121)
            
            ' *** CRITICAL: Load Wet Plant endpoints into source/destination dropdowns ***
            Call Me.UpdateComboBox("tbl_WetPlantEndpoints")
            
        Case Is = "ORE_SORTER"
            ' Set form title based on mode
            Me.caption = IIf(FormMode = "CREATE", "Register New Cable - Ore Sorting Plant", "Edit Cable - Ore Sorting Plant")
            
            ' Set validation patterns for Ore Sorter (plant identifier "2")
            strShortNamePattern = "^[A-Z]{2,3}[2][0-1][0-9]$"      ' e.g., OS201, CV202
            strCircuitNamePattern = "^[C][2][0-9]{3}$"            ' e.g., C2001
            strCableIDPattern = "^[A-Z]{2,3}[2][01][0-9][-][C][2][0-9]{3}[-][A-Z]{2,3}[2][01][0-9]$"
            
            ' Apply teal theming
            Me.BackColor = RGB(0, 176, 240)
            
            ' *** CRITICAL: Load Ore Sorter endpoints into source/destination dropdowns ***
            Call Me.UpdateComboBox("tbl_OreSorterEndpoints")
            
        Case Is = "RETREATMENT"
            ' Set form title based on mode
            Me.caption = IIf(FormMode = "CREATE", "Register New Cable - Retreatment Gravity Plant", "Edit Cable - Retreatment Gravity Plant")
            
            ' Set validation patterns for Retreatment (plant identifier "3")
            strShortNamePattern = "^[A-Z]{2,3}[3][0-1][0-9]$"      ' e.g., RP301, CV302
            strCircuitNamePattern = "^[C][3][0-9]{3}$"            ' e.g., C3001
            strCableIDPattern = "^[A-Z]{2,3}[3][01][0-9][-][C][3][0-9]{3}[-][A-Z]{2,3}[3][01][0-9]$"
            
            ' Apply gray/red theming
            Me.BackColor = RGB(166, 166, 166)
            
            ' *** CRITICAL: Load Retreatment endpoints into source/destination dropdowns ***
            Call Me.UpdateComboBox("tbl_RetreatmentEndpoints")
            
        Case Else
            ' UNRECOGNIZED FORM ID - SHOW ERROR
            MsgBox "Unknown form ID: " & ID_NEW_CAB_FORM & vbCrLf & _
                   "Please check form configuration.", vbCritical, "Configuration Error"
    End Select

ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during form activation
    MsgBox "An error occurred activating the form: " & Err.description, vbCritical, "Activation Error"
    Debug.Print "Error in UserForm_Activate: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' UTILITY FUNCTIONS
' ===============================================================================

' ===============================================================================
' SUBROUTINE: ReloadForm
' PURPOSE: Resets all form controls to their initial empty/disabled state
' NOTES: Used when initializing form or after successful save & continue
' ===============================================================================
Public Sub ReloadForm()
    On Error GoTo ErrorHandler

    ' -----------------------------------------------------------------------
    ' RESET FORM MODE TO CREATE
    ' -----------------------------------------------------------------------
    FormMode = "CREATE"
    UpdateRowIndex = 0

    ' -----------------------------------------------------------------------
    ' RE-ENABLE FIELDS THAT MAY HAVE BEEN DISABLED IN UPDATE MODE
    ' -----------------------------------------------------------------------
    Me.txt_CableID.Enabled = True
    Me.txt_CircuitName.Enabled = True
    Me.cmb_Source.Enabled = True
    Me.cmb_Destination.Enabled = True

    ' -----------------------------------------------------------------------
    ' CLEAR ALL TEXT INPUTS
    ' -----------------------------------------------------------------------
    Me.txt_CableID.Value = ""
    Me.txt_CircuitName.Value = ""
    Me.txt_Length.Value = ""

    ' -----------------------------------------------------------------------
    ' CLEAR ALL DROPDOWN SELECTIONS
    ' -----------------------------------------------------------------------
    Me.cmb_Source.Value = ""
    Me.cmb_Destination.Value = ""
    Me.cmb_CoreSize.Value = ""
    Me.cmb_EarthSize.Value = ""
    Me.cmb_CoreConfig.Value = ""
    Me.cmb_Insulation.Value = ""
    Me.cmb_CableType.Value = ""

    ' -----------------------------------------------------------------------
    ' RESET ALL CHECKBOXES TO UNCHECKED
    ' -----------------------------------------------------------------------
    Me.cb_IsScheduled.Value = False
    Me.cb_IDAttached.Value = False

    ' -----------------------------------------------------------------------
    ' SET FOCUS TO FIRST FIELD FOR USER CONVENIENCE
    ' -----------------------------------------------------------------------
    Me.cmb_Source.SetFocus

ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during form reset
    MsgBox "An error occurred resetting the form: " & Err.description, vbCritical, "Form Error"
    Debug.Print "Error in ReloadForm: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' SUBROUTINE: UpdateComboBox
' PURPOSE: Refreshes dropdown data from Excel tables for endpoints
' PARAMETERS: strEndpointsTableName - Name of Excel table containing endpoint data
' NOTES: Called when form loads or after new endpoints are added
' ===============================================================================
Public Sub UpdateComboBox(ByVal strEndpointsTableName As String)
    On Error GoTo ErrorHandler

    Dim arr As Variant          ' Array to hold endpoint data
    Dim i As Long               ' Loop counter
    Dim strFormID As String     ' FormID to pass to GetEndpointsArray
    
    ' -----------------------------------------------------------------------
    ' CONVERT TABLE NAME TO FORMID
    ' GetEndpointsArray expects FormID, not table name
    ' -----------------------------------------------------------------------
    Select Case UCase(strEndpointsTableName)
        Case "TBL_WETPLANTENDPOINTS"
            strFormID = "WET_PLANT"
        Case "TBL_ORESORTERENDPOINTS"
            strFormID = "ORE_SORTER"
        Case "TBL_RETREATMENTENDPOINTS"
            strFormID = "RETREATMENT"
        Case Else
            ' If we have the FormID already (not table name), use it directly
            strFormID = strEndpointsTableName
    End Select
    
    ' -----------------------------------------------------------------------
    ' RETRIEVE ENDPOINT DATA FROM DATA SHEET
    ' -----------------------------------------------------------------------
    arr = sht_Data.GetEndpointsArray(strFormID)
    
    ' Check if data was successfully retrieved
    If Not IsArray(arr) Then
        Debug.Print "No endpoint data retrieved for: " & strFormID
        Exit Sub
    End If
    
    ' Check if array is empty
    If UBound(arr) < LBound(arr) Then
        Debug.Print "Empty endpoint array for: " & strFormID
        ' Don't show error - empty endpoints is valid during initial setup
        Exit Sub
    End If

    ' -----------------------------------------------------------------------
    ' CLEAR EXISTING DROPDOWN CONTENTS
    ' -----------------------------------------------------------------------
    Me.cmb_Source.Clear
    Me.cmb_Destination.Clear

    ' -----------------------------------------------------------------------
    ' POPULATE DROPDOWNS WITH ENDPOINT DATA
    ' -----------------------------------------------------------------------
    On Error Resume Next ' Continue even if individual items fail
    
    For i = LBound(arr) To UBound(arr)
        If Not arr(i) Is Nothing Then
            ' Add endpoint short name to both dropdowns
            Me.cmb_Source.AddItem arr(i).ShortName
            Me.cmb_Destination.AddItem arr(i).ShortName
        End If
    Next i
    
    On Error GoTo ErrorHandler ' Re-enable error handling

    ' -----------------------------------------------------------------------
    ' POPULATE STATIC DROPDOWN LISTS FROM DATA SHEET
    ' Handle missing tables gracefully
    ' -----------------------------------------------------------------------
    
    On Error Resume Next ' Don't fail if tables don't exist
    
    ' Core sizes (wire cross-sectional area)
    If Not sht_Data.ListObjects("tbl_CableSizes") Is Nothing Then
        If sht_Data.ListObjects("tbl_CableSizes").ListRows.count > 0 Then
            Me.cmb_CoreSize.List = sht_Data.ListObjects("tbl_CableSizes").DataBodyRange.Value
            Me.cmb_EarthSize.List = sht_Data.ListObjects("tbl_CableSizes").DataBodyRange.Value
        End If
    End If
    
    ' Core configurations
    If Not sht_Data.ListObjects("tbl_CoreConfigs") Is Nothing Then
        If sht_Data.ListObjects("tbl_CoreConfigs").ListRows.count > 0 Then
            Me.cmb_CoreConfig.List = sht_Data.ListObjects("tbl_CoreConfigs").DataBodyRange.Value
        End If
    End If
    
    ' Insulation types
    If Not sht_Data.ListObjects("tbl_InsulationTypes") Is Nothing Then
        If sht_Data.ListObjects("tbl_InsulationTypes").ListRows.count > 0 Then
            Me.cmb_Insulation.List = sht_Data.ListObjects("tbl_InsulationTypes").DataBodyRange.Value
        End If
    End If
    
    ' Cable types
    If Not sht_Data.ListObjects("tbl_CableTypes") Is Nothing Then
        If sht_Data.ListObjects("tbl_CableTypes").ListRows.count > 0 Then
            Me.cmb_CableType.List = sht_Data.ListObjects("tbl_CableTypes").DataBodyRange.Value
        End If
    End If
    
    On Error GoTo ErrorHandler ' Re-enable error handling

ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    ' Handle any unexpected errors during combo box update
    Debug.Print "Error in UpdateComboBox: " & Err.Number & " - " & Err.description
    Debug.Print "Table/FormID: " & strEndpointsTableName
    ' Don't show message box - just log to debug
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' FUNCTION: ValidateRequired
' PURPOSE: Validates that all required form fields are filled and valid
' RETURNS: True if all validations pass, False if any validation fails
' NOTES: COMPLETELY REWRITTEN - Fixed logic errors and improved validation
' ===============================================================================
Function ValidateRequired() As Boolean
    On Error GoTo ErrorHandler
    
    ' Default return value (assume failure until all checks pass)
    ValidateRequired = False
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CABLE ID FIELD
    ' Requirement: Cable ID must be present and in correct format
    ' -----------------------------------------------------------------------
    If Trim(Me.txt_CableID.Value & "") = "" Then
        MsgBox "Cable ID is required.", vbExclamation, "Validation Error"
        Me.txt_CableID.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE SOURCE FIELD (Skip if in UPDATE mode - field is disabled)
    ' Requirement: Source endpoint must be selected from dropdown
    ' -----------------------------------------------------------------------
    If FormMode <> "UPDATE" Then
        If Trim(Me.cmb_Source.Value & "") = "" Then
            MsgBox "Source is required.", vbExclamation, "Validation Error"
            Me.cmb_Source.SetFocus  ' Move cursor to problem field
            Exit Function
        End If
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE DESTINATION FIELD (Skip if in UPDATE mode - field is disabled)
    ' Requirement: Destination endpoint must be selected from dropdown
    ' -----------------------------------------------------------------------
    If FormMode <> "UPDATE" Then
        If Trim(Me.cmb_Destination.Value & "") = "" Then
            MsgBox "Destination is required.", vbExclamation, "Validation Error"
            Me.cmb_Destination.SetFocus  ' Move cursor to problem field
            Exit Function
        End If
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CIRCUIT NAME FIELD (Skip if in UPDATE mode - field is disabled)
    ' Requirement: Circuit name must be present (usually auto-generated)
    ' -----------------------------------------------------------------------
    If FormMode <> "UPDATE" Then
        If Trim(Me.txt_CircuitName.Value & "") = "" Then
            MsgBox "Circuit Name is required.", vbExclamation, "Validation Error"
            Me.txt_CircuitName.SetFocus  ' Move cursor to problem field
            Exit Function
        End If
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CORE SIZE FIELD
    ' Requirement: Core size must be selected from dropdown
    ' -----------------------------------------------------------------------
    If Trim(Me.cmb_CoreSize.Value & "") = "" Then
        MsgBox "Core Size is required.", vbExclamation, "Validation Error"
        Me.cmb_CoreSize.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE EARTH SIZE FIELD
    ' Requirement: Earth size must be selected from dropdown
    ' -----------------------------------------------------------------------
    If Trim(Me.cmb_EarthSize.Value & "") = "" Then
        MsgBox "Earth Size is required.", vbExclamation, "Validation Error"
        Me.cmb_EarthSize.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CORE CONFIGURATION FIELD
    ' Requirement: Core configuration must be selected from dropdown
    ' -----------------------------------------------------------------------
    If Trim(Me.cmb_CoreConfig.Value & "") = "" Then
        MsgBox "Core Configuration is required.", vbExclamation, "Validation Error"
        Me.cmb_CoreConfig.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE INSULATION TYPE FIELD
    ' Requirement: Insulation type must be selected from dropdown
    ' -----------------------------------------------------------------------
    If Trim(Me.cmb_Insulation.Value & "") = "" Then
        MsgBox "Insulation Type is required.", vbExclamation, "Validation Error"
        Me.cmb_Insulation.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CABLE TYPE FIELD
    ' Requirement: Cable type must be selected from dropdown
    ' -----------------------------------------------------------------------
    If Trim(Me.cmb_CableType.Value & "") = "" Then
        MsgBox "Cable Type is required.", vbExclamation, "Validation Error"
        Me.cmb_CableType.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' VALIDATE CABLE LENGTH FIELD
    ' Requirement: Cable length must be a positive number
    ' -----------------------------------------------------------------------
    If Trim(Me.txt_Length.Value & "") = "" Then
        MsgBox "Cable Length is required.", vbExclamation, "Validation Error"
        Me.txt_Length.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' Additional validation: Check if length is a valid number
    If Not IsNumeric(Me.txt_Length.Value) Then
        MsgBox "Cable Length must be a valid number.", vbExclamation, "Validation Error"
        Me.txt_Length.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' Additional validation: Check if length is positive
    If CDbl(Me.txt_Length.Value) <= 0 Then
        MsgBox "Cable Length must be greater than zero.", vbExclamation, "Validation Error"
        Me.txt_Length.SetFocus  ' Move cursor to problem field
        Exit Function
    End If
    
    ' -----------------------------------------------------------------------
    ' ALL VALIDATIONS PASSED
    ' If we reach this point, all required fields are valid
    ' -----------------------------------------------------------------------
    ValidateRequired = True

ErrorHandler_Exit:
    Exit Function

ErrorHandler:
    ' Handle any unexpected errors during validation
    MsgBox "An error occurred during validation: " & Err.description, vbCritical, "Validation Error"
    Debug.Print "Error in ValidateRequired: " & Err.Number & " - " & Err.description
    ValidateRequired = False  ' Ensure function returns False on error
    Resume ErrorHandler_Exit
End Function

' ===============================================================================
' FUNCTION: GetNewCable
' PURPOSE: Creates and populates a new Cable object with current form data
' RETURNS: clCable object populated with all form field values
' NOTES: Used by save functions to package form data for database storage
' ===============================================================================
Public Function GetNewCable() As Variant
    On Error GoTo ErrorHandler

    ' -----------------------------------------------------------------------
    ' CREATE NEW CABLE OBJECT
    ' -----------------------------------------------------------------------
    Dim cNewCable As New clCable          ' New cable object to populate
    Dim strSourceDesc As String           ' Full description of source endpoint
    Dim strDestDesc As String             ' Full description of destination endpoint
    
    ' -----------------------------------------------------------------------
    ' GET ENDPOINT DESCRIPTIONS FROM DATABASE
    ' Convert short codes (like "WM101") to full descriptions
    ' -----------------------------------------------------------------------
    strSourceDesc = modDatabase.GetEndpointDescription(ID_NEW_CAB_FORM, CStr(Me.cmb_Source.Value))
    strDestDesc = modDatabase.GetEndpointDescription(ID_NEW_CAB_FORM, CStr(Me.cmb_Destination.Value))

    ' -----------------------------------------------------------------------
    ' POPULATE CABLE OBJECT WITH FORM DATA
    ' Map each form field to corresponding cable property
    ' -----------------------------------------------------------------------
    With cNewCable
        ' Checkbox values (Boolean)
        .Scheduled = Me.cb_IsScheduled.Value        ' Whether cable installation is scheduled
        .IDAttached = Me.cb_IDAttached.Value        ' Whether ID label is physically attached
        
        ' Text field values (String)
        .cableID = Me.txt_CableID.Value             ' Unique cable identifier
        .Source = strSourceDesc                     ' Full source endpoint description
        .Destination = strDestDesc                  ' Full destination endpoint description
        .CableLength = Me.txt_Length.Value          ' Cable length in meters
        
        ' Dropdown selection values (String)
        .CoreSize = Me.cmb_CoreSize.Value           ' Wire core cross-sectional area
        .EarthSize = Me.cmb_EarthSize.Value         ' Earth/ground wire size
        .CoreConfig = Me.cmb_CoreConfig.Value       ' Number and arrangement of cores
        .InsulationType = Me.cmb_Insulation.Value   ' Insulation material type
        .CableType = Me.cmb_CableType.Value         ' Physical cable construction type
    End With
    
    ' -----------------------------------------------------------------------
    ' RETURN POPULATED CABLE OBJECT
    ' -----------------------------------------------------------------------
    Set GetNewCable = cNewCable

ErrorHandler_Exit:
    Exit Function

ErrorHandler:
    ' Handle any unexpected errors during cable object creation
    MsgBox "An error occurred creating cable object: " & Err.description, vbCritical, "Object Creation Error"
    Debug.Print "Error in GetNewCable: " & Err.Number & " - " & Err.description
    
    ' Return Nothing on error to indicate failure
    Set GetNewCable = Nothing
    Resume ErrorHandler_Exit
End Function

' ===============================================================================
' SUBROUTINE: ShowForUpdate - CORRECTED VERSION
' PURPOSE: Opens the form in UPDATE mode with existing cable data pre-populated
' PARAMETERS: cableToEdit - clCable object containing existing cable data
'            strFormID - Plant type identifier ("WET_PLANT", "ORE_SORTER", "RETREATMENT")
'            lngRowIndex - The row index of the cable being edited
' NOTES: *** FIX: Now populates combo boxes BEFORE setting their values ***
'        This prevents the "Invalid property value" error
' ===============================================================================
Public Sub ShowForUpdate(cableToEdit As clCable, strFormID As String, lngRowIndex As Long)
    On Error GoTo ErrorHandler
    
    ' Set form mode to UPDATE
    FormMode = "UPDATE"
    UpdateRowIndex = lngRowIndex
    
    ' Set the plant type identifier
    Me.txt_FormID.Value = strFormID
    
    ' -----------------------------------------------------------------------
    ' POPULATE COMBO BOXES BEFORE SETTING VALUES
    ' -----------------------------------------------------------------------
    Dim strTableName As String
    Select Case strFormID
        Case "WET_PLANT": strTableName = "tbl_WetPlantEndpoints"
        Case "ORE_SORTER": strTableName = "tbl_OreSorterEndpoints"
        Case "RETREATMENT": strTableName = "tbl_RetreatmentEndpoints"
    End Select
    
    ' Populate all combo box lists
    Call Me.UpdateComboBox(strTableName)
    
    ' -----------------------------------------------------------------------
    ' CONVERT STORED DESCRIPTIONS TO SHORT NAMES FOR COMBO BOXES
    ' The cable record stores full descriptions ("Conveyor belt 1")
    ' But combo boxes contain short names ("CB101")
    ' So we need to look up the short name for each description
    ' -----------------------------------------------------------------------
    Dim strSourceShortName As String
    Dim strDestShortName As String
    
    ' Look up short names from the full descriptions
    strSourceShortName = GetShortNameFromDescription(cableToEdit.Source, strFormID)
    strDestShortName = GetShortNameFromDescription(cableToEdit.Destination, strFormID)
    
    ' Debug output to verify the conversion
    Debug.Print "========== ShowForUpdate Debug =========="
    Debug.Print "Cable ID: " & cableToEdit.cableID
    Debug.Print "FormID: " & strFormID
    Debug.Print "Source (stored description): [" & cableToEdit.Source & "]"
    Debug.Print "Source (converted short name): [" & strSourceShortName & "]"
    Debug.Print "Destination (stored description): [" & cableToEdit.Destination & "]"
    Debug.Print "Destination (converted short name): [" & strDestShortName & "]"
    
    ' -----------------------------------------------------------------------
    ' CRITICAL VALIDATION: Check if lookup failed
    ' If lookup returns empty string but we had a value, this means the
    ' endpoint doesn't exist in the endpoints table, and we should ABORT
    ' to prevent data loss
    ' -----------------------------------------------------------------------
    Dim bLookupFailed As Boolean
    bLookupFailed = False
    
    If Len(Trim(strSourceShortName)) = 0 And Len(Trim(cableToEdit.Source)) > 0 Then
        Debug.Print "X ERROR: Source lookup FAILED - could not find short name for: [" & cableToEdit.Source & "]"
        bLookupFailed = True
    End If
    
    If Len(Trim(strDestShortName)) = 0 And Len(Trim(cableToEdit.Destination)) > 0 Then
        Debug.Print "X ERROR: Destination lookup FAILED - could not find short name for: [" & cableToEdit.Destination & "]"
        bLookupFailed = True
    End If
    
    ' If lookup failed, show detailed error and ABORT to prevent data loss
    If bLookupFailed Then
        Dim errMsg As String
        errMsg = "CRITICAL ERROR: Cannot edit cable - endpoint lookup failed!" & vbCrLf & vbCrLf
        errMsg = errMsg & "Cable ID: " & cableToEdit.cableID & vbCrLf & vbCrLf
        errMsg = errMsg & "MISSING ENDPOINTS:" & vbCrLf
        
        If Len(Trim(strSourceShortName)) = 0 And Len(Trim(cableToEdit.Source)) > 0 Then
            errMsg = errMsg & "  X Source: """ & cableToEdit.Source & """" & vbCrLf
        End If
        
        If Len(Trim(strDestShortName)) = 0 And Len(Trim(cableToEdit.Destination)) > 0 Then
            errMsg = errMsg & "  X Destination: """ & cableToEdit.Destination & """" & vbCrLf
        End If
        
        errMsg = errMsg & vbCrLf & "POSSIBLE CAUSES:" & vbCrLf
        errMsg = errMsg & "  1. The endpoint was deleted from the endpoints table" & vbCrLf
        errMsg = errMsg & "  2. The endpoint description has spelling/spacing differences" & vbCrLf
        errMsg = errMsg & "  3. The cable has invalid endpoint data" & vbCrLf & vbCrLf
        
        errMsg = errMsg & "ACTION REQUIRED:" & vbCrLf
        errMsg = errMsg & "  1. Press Ctrl+G to open Immediate Window for debug info" & vbCrLf
        errMsg = errMsg & "  2. Run: DiagnoseEndpointLookup """ & cableToEdit.cableID & """, """ & strFormID & """" & vbCrLf
        errMsg = errMsg & "  3. Check the endpoints table for missing endpoints" & vbCrLf & vbCrLf
        
        errMsg = errMsg & "PROTECTION: Edit operation CANCELLED to prevent data loss." & vbCrLf
        errMsg = errMsg & "If you proceed, the Source/Destination fields would be erased!"
        
        MsgBox errMsg, vbCritical, "Data Loss Prevention - Edit Cancelled"
        
        Debug.Print "========== Edit CANCELLED - Data Loss Prevention Active =========="
        Debug.Print "To diagnose the issue, run this in Immediate Window (Ctrl+G):"
        Debug.Print "  DiagnoseEndpointLookup """ & cableToEdit.cableID & """, """ & strFormID & """"
        Debug.Print "========================================="
        
        ' ABORT: Do not show the form
        Exit Sub
    End If
    
    Debug.Print "* Lookup successful - proceeding with form population"
    Debug.Print "========================================="
    
    ' -----------------------------------------------------------------------
    ' NOW POPULATE THE FORM FIELDS
    ' Only reached if lookup was successful
    ' -----------------------------------------------------------------------
    With Me
        ' Checkboxes
        .cb_IsScheduled.Value = cableToEdit.Scheduled
        .cb_IDAttached.Value = cableToEdit.IDAttached
        
        ' Text fields
        .txt_CableID.Value = cableToEdit.cableID
        .txt_CircuitName.Value = ExtractCircuitName(cableToEdit.cableID)
        .txt_Length.Value = cableToEdit.CableLength
        
        ' Combo boxes - use the looked-up SHORT NAMES
        .cmb_Source.Value = strSourceShortName
        .cmb_Destination.Value = strDestShortName
        .cmb_CoreSize.Value = cableToEdit.CoreSize
        .cmb_EarthSize.Value = cableToEdit.EarthSize
        .cmb_CoreConfig.Value = cableToEdit.CoreConfig
        .cmb_Insulation.Value = cableToEdit.InsulationType
        .cmb_CableType.Value = cableToEdit.CableType
    End With
    
    ' Update form caption
    Me.caption = "Edit Cable - " & cableToEdit.cableID
    
    ' Disable key fields during edit
    Me.txt_CableID.Enabled = False
    Me.txt_CircuitName.Enabled = False
    Me.cmb_Source.Enabled = False
    Me.cmb_Destination.Enabled = False
    
    ' Show the form
    Me.Show
    
ErrorHandler_Exit:
    Exit Sub

ErrorHandler:
    MsgBox "An error occurred loading cable for edit: " & Err.description, vbCritical, "Load Error"
    Debug.Print "Error in ShowForUpdate: " & Err.Number & " - " & Err.description
    Resume ErrorHandler_Exit
End Sub

' ===============================================================================
' FUNCTION: ExtractCircuitName
' PURPOSE: Extracts the circuit name portion from a full cable ID
' PARAMETERS: cableID - Full cable ID (e.g., "WM101-C1001-CV102")
' RETURNS: String - Circuit name portion (e.g., "C1001")
' NOTES: Helper function for populating form during edit mode
' ===============================================================================
Private Function ExtractCircuitName(cableID As String) As String
    On Error GoTo ErrorHandler
    
    Dim parts() As String
    parts = Split(cableID, "-")
    
    ' Cable ID format is: SOURCE-CIRCUIT-DESTINATION
    If UBound(parts) >= 1 Then
        ExtractCircuitName = parts(1)
    Else
        ExtractCircuitName = ""
    End If
    
ErrorHandler_Exit:
    Exit Function

ErrorHandler:
    ExtractCircuitName = ""
    Resume ErrorHandler_Exit
End Function

' ===============================================================================
' FUNCTION: ExtractShortName
' PURPOSE: Extracts the short name (code) from a full endpoint description
' PARAMETERS: fullDescription - Full endpoint description (e.g., "WM101 - Main Pump")
' RETURNS: String - Short name portion (e.g., "WM101")
' NOTES: Helper function for populating form during edit mode
'        Endpoint descriptions are stored as "CODE - Description"
' ===============================================================================
Private Function ExtractShortName(fullDescription As String) As String
    On Error GoTo ErrorHandler
    
    Dim parts() As String
    
    ' Check if description contains the delimiter
    If InStr(fullDescription, " - ") > 0 Then
        parts = Split(fullDescription, " - ")
        ExtractShortName = Trim(parts(0))
    Else
        ' If no delimiter found, assume the entire string is the short name
        ExtractShortName = Trim(fullDescription)
    End If
    
ErrorHandler_Exit:
    Exit Function

ErrorHandler:
    ExtractShortName = ""
    Resume ErrorHandler_Exit
End Function

' -------------------------------------------------------------------------------
' FUNCTION: GetShortNameFromDescription (NEW FUNCTION)
' PURPOSE: Looks up the short name for a given endpoint description
' PARAMETERS: fullDescription - The full description stored in the cable record
'            strFormID - Plant type to search in
' RETURNS: String - The short name (e.g., "CB101") or empty string if not found
' NOTES: This is the REVERSE of GetEndpointDescription
'        Needed because cables store full descriptions but combo boxes use short names
' -------------------------------------------------------------------------------
Private Function GetShortNameFromDescription(fullDescription As String, strFormID As String) As String
    On Error GoTo ErrorHandler
    
    ' Get all endpoints for this plant type
    Dim arrEndpoints As Variant
    arrEndpoints = sht_Data.GetEndpointsArray(strFormID)
    
    ' Handle empty array case
    If Not IsArray(arrEndpoints) Then
        GetShortNameFromDescription = ""
        Exit Function
    End If
    
    ' Search for matching description
    Dim epItem As Variant
    For Each epItem In arrEndpoints
        ' Check if the description matches (case-insensitive)
        If StrComp(epItem.description, Trim(fullDescription), vbTextCompare) = 0 Then
            ' Found it! Return the short name
            GetShortNameFromDescription = epItem.ShortName
            Exit Function
        End If
    Next epItem
    
    ' Not found - return empty string
    GetShortNameFromDescription = ""
    
ErrorHandler_Exit:
    Exit Function

ErrorHandler:
    Debug.Print "Error in GetShortNameFromDescription: " & Err.description
    GetShortNameFromDescription = ""
    Resume ErrorHandler_Exit
End Function

' ===============================================================================
' VALIDATION PATTERN EXPLANATIONS AND EXAMPLES
' ===============================================================================
'
' SHORT NAME PATTERNS (Source/Destination):
' - Wet Plant:     ^[A-Z]{2,3}[1][0-1][0-9]$    (e.g., WM101, CV102, ABC101)
' - Ore Sorter:    ^[A-Z]{2,3}[2][0-1][0-9]$    (e.g., OS201, CV202, ABC201)
' - Retreatment:   ^[A-Z]{2,3}[3][0-1][0-9]$    (e.g., RP301, CV302, ABC301)
'
' CIRCUIT NAME PATTERNS:
' - Wet Plant:     ^[C][1][0-9]{3}$             (e.g., C1001, C1002, C1999)
' - Ore Sorter:    ^[C][2][0-9]{3}$             (e.g., C2001, C2002, C2999)
' - Retreatment:   ^[C][3][0-9]{3}$             (e.g., C3001, C3002, C3999)
'
' CABLE ID PATTERNS (Source-Circuit-Destination):
' - Wet Plant:     ^[A-Z]{2,3}[1][01][0-9][-][C][1][0-9]{3}[-][A-Z]{2,3}[1][01][0-9]$
' - Ore Sorter:    ^[A-Z]{2,3}[2][01][0-9][-][C][2][0-9]{3}[-][A-Z]{2,3}[2][01][0-9]$
' - Retreatment:   ^[A-Z]{2,3}[3][01][0-9][-][C][3][0-9]{3}[-][A-Z]{2,3}[3][01][0-9]$
'
' Examples of complete Cable IDs:
' - Wet Plant:     WM101-C1001-CV102
' - Ore Sorter:    OS201-C2001-CV202
' - Retreatment:   RP301-C3001-CV302
'
' ===============================================================================


-------------------------------------------------------------------------------
VBA MACRO ModRowActions.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/ModRowActions'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: ModRowActions (Standard Module)
' AUTHOR: jorr@mtcarbine.com.au (enhanced with AI assistance)
' DATE: 20-12-24
' PURPOSE: Provides dynamic row-level action buttons (Edit/Delete) that appear
'          next to selected rows in cable management worksheets. Implements a
'          floating button UI pattern that moves with user selection for quick
'          access to row operations without cluttering the worksheet.
' ==============================================================================

Option Explicit

' ==============================================================================
' MODULE-LEVEL CONSTANTS - BUTTON APPEARANCE AND POSITIONING
' ==============================================================================

' Button dimensions in points
Private Const BTN_WIDTH As Single = 28          ' Width of action buttons
Private Const BTN_HEIGHT As Single = 16         ' Height of action buttons
Private Const BTN_GAP As Single = 6             ' Space between Edit and Delete buttons

' Button text formatting
Private Const BTN_FONT_SIZE As Single = 11      ' Font size for button text

' Positioning configuration
Private Const BTN_OFFSET_COLS As Long = 1       ' Columns to right of last data column

' ==============================================================================
' PUBLIC API - WORKSHEET EVENT INTEGRATION
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: OnSelectionChangedForRowButtons
' PURPOSE: Main entry point called from Worksheet_SelectionChange events
' PARAMETERS: ws - The worksheet where selection changed
'            Target - The range that was selected
' NOTES: Call this from each plant worksheet's SelectionChange event handler
'        Only responds to single-row selections to avoid ambiguity
'        Automatically hides buttons when multi-row selection occurs
'------------------------------------------------------------------------------
Public Sub OnSelectionChangedForRowButtons(ByVal ws As Worksheet, ByVal Target As Range)
    On Error GoTo CleanFail
    
    ' Validate inputs
    If ws Is Nothing Then Exit Sub
    If Target Is Nothing Then Exit Sub

    ' Only show buttons for single-row selections to keep behavior predictable
    ' Multi-row selections could be ambiguous about which row to act on
    If Target.Rows.count > 1 Then
        HideRowButtons ws
        Exit Sub
    End If

    ' Optional: Ignore header row selections
    ' Uncomment the following lines if you want to prevent buttons on header row
    'If Target.Row = 1 Then
    '    HideRowButtons ws
    '    Exit Sub
    'End If

    ' Position and show the action buttons for the selected row
    PositionRowButtons ws, Target.Row
    
    Exit Sub
    
CleanFail:
    ' Non-fatal error - silently fail to avoid disrupting user workflow
    ' Button functionality is convenience feature, not critical
End Sub

'------------------------------------------------------------------------------
' SUBROUTINE: HideRowButtons
' PURPOSE: Hides the floating action buttons on a worksheet
' PARAMETERS: ws - The worksheet containing the buttons
' NOTES: Called when worksheet is deactivated or when selection is invalid
'        Uses On Error Resume Next since buttons may not exist yet
'------------------------------------------------------------------------------
Public Sub HideRowButtons(ByVal ws As Worksheet)
    On Error Resume Next
    
    ' Hide both action buttons (ignore errors if they don't exist)
    ws.Shapes("AI_RowDel").Visible = msoFalse
    ws.Shapes("AI_RowEdit").Visible = msoFalse
    
End Sub

' ==============================================================================
' PRIVATE METHODS - BUTTON POSITIONING AND CREATION
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: PositionRowButtons
' PURPOSE: Positions the Edit and Delete buttons next to the specified row
' PARAMETERS: ws - The worksheet containing the buttons
'            rowNum - The row number to position buttons next to
' NOTES: Buttons appear one column to the right of last used column
'        Uses cell alignment to vertically center buttons in the row
'        Stores row number in button's AlternativeText for callback identification
'------------------------------------------------------------------------------
Private Sub PositionRowButtons(ByVal ws As Worksheet, ByVal rowNum As Long)
    On Error GoTo CleanFail
    
    ' Determine where to place buttons (one column right of last data)
    Dim lastCol As Long, targetCol As Long
    lastCol = LastUsedCol(ws)
    If lastCol < 1 Then lastCol = 1
    
    ' Position buttons one column to the right of the last used column
    targetCol = lastCol + BTN_OFFSET_COLS
    If targetCol > ws.Columns.count Then targetCol = ws.Columns.count
    
    ' Get the cell where buttons will be positioned
    Dim cell As Range
    Set cell = ws.Cells(rowNum, targetCol)
    
    ' Calculate button positions - vertically centered in row, left-aligned in column
    Dim topPos As Double, leftBase As Double
    topPos = cell.Top + (cell.Height - BTN_HEIGHT) / 2  ' Vertical centering
    leftBase = cell.Left + 2                             ' Small left padding
    
    ' Ensure buttons exist (creates them if needed)
    Dim delBtn As Shape, editBtn As Shape
    Set delBtn = EnsureButton(ws, "AI_RowDel", "Del")
    Set editBtn = EnsureButton(ws, "AI_RowEdit", "Edit")
    
    ' Position and configure Delete button
    With delBtn
        .Top = topPos
        .Left = leftBase
        .Visible = msoTrue
        .AlternativeText = CStr(rowNum)                    ' Store row number for callback
        .OnAction = "ModRowActions.DeleteRow_FromButton"   ' Wire up click handler
    End With
    
    ' Position and configure Edit button (to the right of Delete)
    With editBtn
        .Top = topPos
        .Left = leftBase + BTN_WIDTH + BTN_GAP
        .Visible = msoTrue
        .AlternativeText = CStr(rowNum)                    ' Store row number for callback
        .OnAction = "ModRowActions.UpdateRow_FromButton"   ' Wire up click handler
    End With
    
    Exit Sub
    
CleanFail:
    ' Non-fatal error - button positioning failure shouldn't break workflow
End Sub

'------------------------------------------------------------------------------
' FUNCTION: EnsureButton
' PURPOSE: Gets existing button or creates new one if it doesn't exist
' PARAMETERS: ws - The worksheet to create button on
'            name - Unique name for the button shape
'            caption - Text to display on the button
' RETURNS: Shape object representing the button
' NOTES: Creates rounded rectangle shapes with color-coded backgrounds
'        Delete buttons are red, Edit buttons are blue
'        Buttons are set to move with cells but not resize
'------------------------------------------------------------------------------
Private Function EnsureButton(ByVal ws As Worksheet, ByVal name As String, ByVal caption As String) As Shape
    On Error GoTo make_new
    
    ' Try to get existing button
    Set EnsureButton = ws.Shapes(name)
    On Error GoTo 0
    
    ' Update existing button properties
    With EnsureButton
        .LockAspectRatio = msoFalse         ' Allow independent width/height
        .Width = BTN_WIDTH
        .Height = BTN_HEIGHT
        .Placement = xlMove                  ' Move with cells, don't resize
        .Visible = msoTrue
        .ZOrder msoBringToFront              ' Keep buttons above other objects
        
        ' Configure button text
        With .TextFrame2
            .TextRange.text = caption
            .TextRange.Font.Size = BTN_FONT_SIZE
            .TextRange.Font.Bold = msoTrue
            .TextRange.Font.Fill.ForeColor.RGB = RGB(0, 0, 0)   ' Black text
            .TextRange.ParagraphFormat.Alignment = msoAlignCenter
            ' Remove internal margins for tight text fit
            .MarginLeft = 0: .MarginRight = 0: .MarginTop = 0: .MarginBottom = 0
        End With
        
        ' Apply color scheme based on button type
        Select Case UCase$(caption)
            Case "DEL"
                .Fill.ForeColor.RGB = RGB(220, 0, 0)   ' Red background
                .Line.ForeColor.RGB = RGB(150, 0, 0)   ' Dark red border
            Case "EDIT"
                .Fill.ForeColor.RGB = RGB(0, 120, 215) ' Blue background (Windows accent)
                .Line.ForeColor.RGB = RGB(0, 80, 150)  ' Dark blue border
            Case Else
                .Fill.ForeColor.RGB = RGB(200, 200, 200)  ' Gray default
                .Line.ForeColor.RGB = RGB(100, 100, 100)
        End Select
    End With
    Exit Function

make_new:
    ' Button doesn't exist - create it
    On Error GoTo 0
    
    Dim s As Shape
    Set s = ws.Shapes.AddShape(Type:=msoShapeRoundedRectangle, _
                               Left:=0, Top:=0, Width:=BTN_WIDTH, Height:=BTN_HEIGHT)
    s.name = name
    s.Placement = xlMove                 ' Move with cells, don't resize
    s.LockAspectRatio = msoFalse        ' Allow independent dimensions
    
    ' Configure new button text
    With s.TextFrame2
        .TextRange.text = caption
        .TextRange.Font.Size = BTN_FONT_SIZE
        .TextRange.Font.Bold = msoTrue
        .TextRange.Font.Fill.ForeColor.RGB = RGB(0, 0, 0)
        .TextRange.ParagraphFormat.Alignment = msoAlignCenter
        .MarginLeft = 0: .MarginRight = 0: .MarginTop = 0: .MarginBottom = 0
    End With
    
    ' Apply color scheme based on button type
    Select Case UCase$(caption)
        Case "DEL"
            s.Fill.ForeColor.RGB = RGB(220, 0, 0)
            s.Line.ForeColor.RGB = RGB(150, 0, 0)
        Case "EDIT"
            s.Fill.ForeColor.RGB = RGB(0, 120, 215)
            s.Line.ForeColor.RGB = RGB(0, 80, 150)
        Case Else
            s.Fill.ForeColor.RGB = RGB(200, 200, 200)
            s.Line.ForeColor.RGB = RGB(100, 100, 100)
    End Select
    
    s.ZOrder msoBringToFront
    Set EnsureButton = s
End Function

'------------------------------------------------------------------------------
' FUNCTION: LastUsedCol
' PURPOSE: Finds the last column containing data in a worksheet
' PARAMETERS: ws - The worksheet to search
' RETURNS: Long - Column number of last used column (1 if sheet is empty)
' NOTES: Uses Excel's Find method searching backwards from end of sheet
'        Searches formulas to catch calculated cells as well as values
'------------------------------------------------------------------------------
Private Function LastUsedCol(ByVal ws As Worksheet) As Long
    On Error Resume Next
    
    ' Search entire sheet backwards by columns to find last used cell
    LastUsedCol = ws.Cells.Find(What:="*", _
                                After:=ws.Cells(1, 1), _
                                LookAt:=xlPart, _
                                LookIn:=xlFormulas, _
                                SearchOrder:=xlByColumns, _
                                SearchDirection:=xlPrevious, _
                                MatchCase:=False).Column
    
    ' If no data found (empty sheet), default to column 1
    If Err.Number <> 0 Then
        Err.Clear
        LastUsedCol = 1
    End If
End Function

' ==============================================================================
' PUBLIC METHODS - BUTTON CLICK HANDLERS
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: DeleteRow_FromButton
' PURPOSE: Handles Delete button clicks - properly deletes cable from table
' NOTES: Called via OnAction when Delete button is clicked
'        Retrieves row number from button's AlternativeText property
'        Guards against accidental header row deletion
'        Delegates to plant-specific DeleteCableRow method
'------------------------------------------------------------------------------
Public Sub DeleteRow_FromButton()
    On Error GoTo CleanFail
    
    ' Get the button that was clicked and its associated worksheet
    Dim shpName As String
    shpName = Application.Caller
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Retrieve row number stored in button's AlternativeText
    Dim rowNum As Long
    rowNum = CLng(ws.Shapes(shpName).AlternativeText)

    ' Safety check: don't delete header row
    If rowNum <= 1 Then Exit Sub
    
    ' Confirm deletion with user
    Dim response As VbMsgBoxResult
    response = MsgBox("Are you sure you want to delete this cable record?" & vbCrLf & vbCrLf & _
                     "This action cannot be undone.", _
                     vbYesNo + vbQuestion + vbDefaultButton2, "Confirm Delete")
    
    If response = vbNo Then Exit Sub
    
    ' Determine which plant worksheet we're on and call appropriate delete method
    Select Case ws.CodeName
        Case "sht_WetPlant"
            ' Convert worksheet row to table row index (subtract 1 for header)
            sht_WetPlant.DeleteCableRow rowNum - 1
        Case "sht_OreSorter"
            sht_OreSorter.DeleteCableRow rowNum - 1
        Case "sht_Retreatment"
            sht_Retreatment.DeleteCableRow rowNum - 1
        Case Else
            ' Fallback for unknown worksheets - delete entire row
            MsgBox "Warning: Using generic row deletion for this worksheet.", vbExclamation
            ws.Rows(rowNum).Delete
    End Select
    
    ' Hide buttons after deletion
    HideRowButtons ws
    
    Exit Sub
    
CleanFail:
    HandleError "ModRowActions", "DeleteRow_FromButton", Err.Number, Err.description, Erl
End Sub

'------------------------------------------------------------------------------
' SUBROUTINE: UpdateRow_FromButton
' PURPOSE: Handles Edit button clicks - opens cable for editing
' NOTES: Called via OnAction when Edit button is clicked
'        Retrieves row number from button's AlternativeText property
'        Delegates to UpdateRow_Impl for business logic
'------------------------------------------------------------------------------
Public Sub UpdateRow_FromButton()
    On Error GoTo CleanFail
    
    ' Get the button that was clicked and its associated worksheet
    Dim shpName As String
    shpName = Application.Caller
    Dim ws As Worksheet
    Set ws = ActiveSheet
    
    ' Retrieve row number stored in button's AlternativeText
    Dim rowNum As Long
    rowNum = CLng(ws.Shapes(shpName).AlternativeText)

    ' Delegate to implementation method
    UpdateRow_Impl ws, rowNum
    
    Exit Sub
    
CleanFail:
    HandleError "ModRowActions", "UpdateRow_FromButton", Err.Number, Err.description, Erl
End Sub
'------------------------------------------------------------------------------
' SUBROUTINE: UpdateRow_Impl
' PURPOSE: Business logic for editing a cable row
' PARAMETERS: ws - The worksheet containing the cable
'            rowNum - The worksheet row number (not table index)
' NOTES: Loads cable data from worksheet and opens frm_RegisterCable in update mode
'------------------------------------------------------------------------------
Public Sub UpdateRow_Impl(ByVal ws As Worksheet, ByVal rowNum As Long)
    On Error GoTo CleanFail
    
    ' Determine plant type from worksheet
    Dim strFormID As String
    Select Case ws.CodeName
        Case "sht_WetPlant"
            strFormID = "WET_PLANT"
        Case "sht_OreSorter"
            strFormID = "ORE_SORTER"
        Case "sht_Retreatment"
            strFormID = "RETREATMENT"
        Case Else
            MsgBox "Cannot edit cables on this worksheet.", vbExclamation
            Exit Sub
    End Select
    
    ' Get the table row index (worksheet row - 1 for header)
    Dim tableRowIndex As Long
    tableRowIndex = rowNum - 1
    
    ' Safety check: ensure we have a valid table row
    If tableRowIndex < 1 Then
        MsgBox "Cannot edit header row.", vbExclamation
        Exit Sub
    End If
    
    ' Retrieve the cable data from the worksheet
    Dim cableToEdit As clCable
    Set cableToEdit = modDatabase.GetCableByRowIndex(strFormID, tableRowIndex)
    
    ' Check if cable was successfully retrieved
    If cableToEdit Is Nothing Then
        MsgBox "Failed to load cable data for editing.", vbCritical, "Load Error"
        Exit Sub
    End If
    
    ' Open the form in update mode with the cable data
    frm_RegisterCable.ShowForUpdate cableToEdit, strFormID, tableRowIndex
    
Exit Sub
    
CleanFail:
    HandleError "ModRowActions", "UpdateRow_Impl", Err.Number, Err.description, Erl
End Sub

-------------------------------------------------------------------------------
VBA MACRO JsonConverter.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/JsonConverter'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
''
' VBA-JSON v2.3.1
' (c) Tim Hall - https://github.com/VBA-tools/VBA-JSON
'
' JSON Converter for VBA
'
' Errors:
' 10001 - JSON parse error
'
' @class JsonConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
'
' Based originally on vba-json (with extensive changes)
' BSD license included below
'
' JSONLib, http://code.google.com/p/vba-json/
'
' Copyright (c) 2013, Ryo Yokoyama
' All rights reserved.
'
' Redistribution and use in source and binary forms, with or without
' modification, are permitted provided that the following conditions are met:
'     * Redistributions of source code must retain the above copyright
'       notice, this list of conditions and the following disclaimer.
'     * Redistributions in binary form must reproduce the above copyright
'       notice, this list of conditions and the following disclaimer in the
'       documentation and/or other materials provided with the distribution.
'     * Neither the name of the <organization> nor the
'       names of its contributors may be used to endorse or promote products
'       derived from this software without specific prior written permission.
'
' THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
' ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
' WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
' DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
' DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
' (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
' LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
' ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
' (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
' SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '
Option Explicit

' === VBA-UTC Headers
#If Mac Then

#If VBA7 Then

' 64-bit Mac (2016)
Private Declare PtrSafe Function utc_popen Lib "/usr/lib/libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As LongPtr
Private Declare PtrSafe Function utc_pclose Lib "/usr/lib/libc.dylib" Alias "pclose" _
    (ByVal utc_File As LongPtr) As LongPtr
Private Declare PtrSafe Function utc_fread Lib "/usr/lib/libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As LongPtr, ByVal utc_Number As LongPtr, ByVal utc_File As LongPtr) As LongPtr
Private Declare PtrSafe Function utc_feof Lib "/usr/lib/libc.dylib" Alias "feof" _
    (ByVal utc_File As LongPtr) As LongPtr

#Else

' 32-bit Mac
Private Declare Function utc_popen Lib "libc.dylib" Alias "popen" _
    (ByVal utc_Command As String, ByVal utc_Mode As String) As Long
Private Declare Function utc_pclose Lib "libc.dylib" Alias "pclose" _
    (ByVal utc_File As Long) As Long
Private Declare Function utc_fread Lib "libc.dylib" Alias "fread" _
    (ByVal utc_Buffer As String, ByVal utc_Size As Long, ByVal utc_Number As Long, ByVal utc_File As Long) As Long
Private Declare Function utc_feof Lib "libc.dylib" Alias "feof" _
    (ByVal utc_File As Long) As Long

#End If

#ElseIf VBA7 Then

' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724421.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms724949.aspx
' http://msdn.microsoft.com/en-us/library/windows/desktop/ms725485.aspx
Private Declare PtrSafe Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare PtrSafe Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare PtrSafe Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#Else

Private Declare Function utc_GetTimeZoneInformation Lib "kernel32" Alias "GetTimeZoneInformation" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION) As Long
Private Declare Function utc_SystemTimeToTzSpecificLocalTime Lib "kernel32" Alias "SystemTimeToTzSpecificLocalTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpUniversalTime As utc_SYSTEMTIME, utc_lpLocalTime As utc_SYSTEMTIME) As Long
Private Declare Function utc_TzSpecificLocalTimeToSystemTime Lib "kernel32" Alias "TzSpecificLocalTimeToSystemTime" _
    (utc_lpTimeZoneInformation As utc_TIME_ZONE_INFORMATION, utc_lpLocalTime As utc_SYSTEMTIME, utc_lpUniversalTime As utc_SYSTEMTIME) As Long

#End If

#If Mac Then

#If VBA7 Then
Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As LongPtr
End Type

#Else

Private Type utc_ShellResult
    utc_Output As String
    utc_ExitCode As Long
End Type

#End If

#Else

Private Type utc_SYSTEMTIME
    utc_wYear As Integer
    utc_wMonth As Integer
    utc_wDayOfWeek As Integer
    utc_wDay As Integer
    utc_wHour As Integer
    utc_wMinute As Integer
    utc_wSecond As Integer
    utc_wMilliseconds As Integer
End Type

Private Type utc_TIME_ZONE_INFORMATION
    utc_Bias As Long
    utc_StandardName(0 To 31) As Integer
    utc_StandardDate As utc_SYSTEMTIME
    utc_StandardBias As Long
    utc_DaylightName(0 To 31) As Integer
    utc_DaylightDate As utc_SYSTEMTIME
    utc_DaylightBias As Long
End Type

#End If
' === End VBA-UTC

Private Type json_Options
    ' VBA only stores 15 significant digits, so any numbers larger than that are truncated
    ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
    ' See: http://support.microsoft.com/kb/269370
    '
    ' By default, VBA-JSON will use String for numbers longer than 15 characters that contain only digits
    ' to override set `JsonConverter.JsonOptions.UseDoubleForLargeNumbers = True`
    UseDoubleForLargeNumbers As Boolean

    ' The JSON standard requires object keys to be quoted (" or '), use this option to allow unquoted keys
    AllowUnquotedKeys As Boolean

    ' The solidus (/) is not required to be escaped, use this option to escape them as \/ in ConvertToJson
    EscapeSolidus As Boolean
End Type
Public JsonOptions As json_Options

' ============================================= '
' Public Methods
' ============================================= '

''
' Convert JSON string to object (Dictionary/Collection)
'
' @method ParseJson
' @param {String} json_String
' @return {Object} (Dictionary or Collection)
' @throws 10001 - JSON parse error
''
Public Function ParseJson(ByVal JsonString As String) As Object
    Dim json_Index As Long
    json_Index = 1

    ' Remove vbCr, vbLf, and vbTab from json_String
    JsonString = VBA.Replace(VBA.Replace(VBA.Replace(JsonString, VBA.vbCr, ""), VBA.vbLf, ""), VBA.vbTab, "")

    json_SkipSpaces JsonString, json_Index
    Select Case VBA.Mid$(JsonString, json_Index, 1)
    Case "{"
        Set ParseJson = json_ParseObject(JsonString, json_Index)
    Case "["
        Set ParseJson = json_ParseArray(JsonString, json_Index)
    Case Else
        ' Error: Invalid JSON string
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(JsonString, json_Index, "Expecting '{' or '['")
    End Select
End Function

''
' Convert object (Dictionary/Collection/Array) to JSON
'
' @method ConvertToJson
' @param {Variant} JsonValue (Dictionary, Collection, or Array)
' @param {Integer|String} Whitespace "Pretty" print json with given number of spaces per indentation (Integer) or given string
' @return {String}
''
Public Function ConvertToJson(ByVal JsonValue As Variant, Optional ByVal Whitespace As Variant, Optional ByVal json_CurrentIndentation As Long = 0) As String
    Dim json_Buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long
    Dim json_Index As Long
    Dim json_LBound As Long
    Dim json_UBound As Long
    Dim json_IsFirstItem As Boolean
    Dim json_Index2D As Long
    Dim json_LBound2D As Long
    Dim json_UBound2D As Long
    Dim json_IsFirstItem2D As Boolean
    Dim json_Key As Variant
    Dim json_Value As Variant
    Dim json_DateStr As String
    Dim json_Converted As String
    Dim json_SkipItem As Boolean
    Dim json_PrettyPrint As Boolean
    Dim json_Indentation As String
    Dim json_InnerIndentation As String

    json_LBound = -1
    json_UBound = -1
    json_IsFirstItem = True
    json_LBound2D = -1
    json_UBound2D = -1
    json_IsFirstItem2D = True
    json_PrettyPrint = Not IsMissing(Whitespace)

    Select Case VBA.VarType(JsonValue)
    Case VBA.vbNull
        ConvertToJson = "null"
    Case VBA.vbDate
        ' Date
        json_DateStr = ConvertToIso(VBA.CDate(JsonValue))

        ConvertToJson = """" & json_DateStr & """"
    Case VBA.vbString
        ' String (or large number encoded as string)
        If Not JsonOptions.UseDoubleForLargeNumbers And json_StringIsLargeNumber(JsonValue) Then
            ConvertToJson = JsonValue
        Else
            ConvertToJson = """" & json_Encode(JsonValue) & """"
        End If
    Case VBA.vbBoolean
        If JsonValue Then
            ConvertToJson = "true"
        Else
            ConvertToJson = "false"
        End If
    Case VBA.vbArray To VBA.vbArray + VBA.vbByte
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
                json_InnerIndentation = VBA.String$(json_CurrentIndentation + 2, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
                json_InnerIndentation = VBA.Space$((json_CurrentIndentation + 2) * Whitespace)
            End If
        End If

        ' Array
        json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength

        On Error Resume Next

        json_LBound = LBound(JsonValue, 1)
        json_UBound = UBound(JsonValue, 1)
        json_LBound2D = LBound(JsonValue, 2)
        json_UBound2D = UBound(JsonValue, 2)

        If json_LBound >= 0 And json_UBound >= 0 Then
            For json_Index = json_LBound To json_UBound
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    ' Append comma to previous line
                    json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                End If

                If json_LBound2D >= 0 And json_UBound2D >= 0 Then
                    ' 2D Array
                    If json_PrettyPrint Then
                        json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                    End If
                    json_BufferAppend json_Buffer, json_Indentation & "[", json_BufferPosition, json_BufferLength

                    For json_Index2D = json_LBound2D To json_UBound2D
                        If json_IsFirstItem2D Then
                            json_IsFirstItem2D = False
                        Else
                            json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                        End If

                        json_Converted = ConvertToJson(JsonValue(json_Index, json_Index2D), Whitespace, json_CurrentIndentation + 2)

                        ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                        If json_Converted = "" Then
                            ' (nest to only check if converted = "")
                            If json_IsUndefined(JsonValue(json_Index, json_Index2D)) Then
                                json_Converted = "null"
                            End If
                        End If

                        If json_PrettyPrint Then
                            json_Converted = vbNewLine & json_InnerIndentation & json_Converted
                        End If

                        json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                    Next json_Index2D

                    If json_PrettyPrint Then
                        json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength
                    End If

                    json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
                    json_IsFirstItem2D = True
                Else
                    ' 1D Array
                    json_Converted = ConvertToJson(JsonValue(json_Index), Whitespace, json_CurrentIndentation + 1)

                    ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                    If json_Converted = "" Then
                        ' (nest to only check if converted = "")
                        If json_IsUndefined(JsonValue(json_Index)) Then
                            json_Converted = "null"
                        End If
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & json_Converted
                    End If

                    json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                End If
            Next json_Index
        End If

        On Error GoTo 0

        If json_PrettyPrint Then
            json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength

            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
            Else
                json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
            End If
        End If

        json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength

        ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)

    ' Dictionary or Collection
    Case VBA.vbObject
        If json_PrettyPrint Then
            If VBA.VarType(Whitespace) = VBA.vbString Then
                json_Indentation = VBA.String$(json_CurrentIndentation + 1, Whitespace)
            Else
                json_Indentation = VBA.Space$((json_CurrentIndentation + 1) * Whitespace)
            End If
        End If

        ' Dictionary
        If VBA.TypeName(JsonValue) = "Dictionary" Then
            json_BufferAppend json_Buffer, "{", json_BufferPosition, json_BufferLength
            For Each json_Key In JsonValue.Keys
                ' For Objects, undefined (Empty/Nothing) is not added to object
                json_Converted = ConvertToJson(JsonValue(json_Key), Whitespace, json_CurrentIndentation + 1)
                If json_Converted = "" Then
                    json_SkipItem = json_IsUndefined(JsonValue(json_Key))
                Else
                    json_SkipItem = False
                End If

                If Not json_SkipItem Then
                    If json_IsFirstItem Then
                        json_IsFirstItem = False
                    Else
                        json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                    End If

                    If json_PrettyPrint Then
                        json_Converted = vbNewLine & json_Indentation & """" & json_Key & """: " & json_Converted
                    Else
                        json_Converted = """" & json_Key & """:" & json_Converted
                    End If

                    json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
                End If
            Next json_Key

            If json_PrettyPrint Then
                json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            json_BufferAppend json_Buffer, json_Indentation & "}", json_BufferPosition, json_BufferLength

        ' Collection
        ElseIf VBA.TypeName(JsonValue) = "Collection" Then
            json_BufferAppend json_Buffer, "[", json_BufferPosition, json_BufferLength
            For Each json_Value In JsonValue
                If json_IsFirstItem Then
                    json_IsFirstItem = False
                Else
                    json_BufferAppend json_Buffer, ",", json_BufferPosition, json_BufferLength
                End If

                json_Converted = ConvertToJson(json_Value, Whitespace, json_CurrentIndentation + 1)

                ' For Arrays/Collections, undefined (Empty/Nothing) is treated as null
                If json_Converted = "" Then
                    ' (nest to only check if converted = "")
                    If json_IsUndefined(json_Value) Then
                        json_Converted = "null"
                    End If
                End If

                If json_PrettyPrint Then
                    json_Converted = vbNewLine & json_Indentation & json_Converted
                End If

                json_BufferAppend json_Buffer, json_Converted, json_BufferPosition, json_BufferLength
            Next json_Value

            If json_PrettyPrint Then
                json_BufferAppend json_Buffer, vbNewLine, json_BufferPosition, json_BufferLength

                If VBA.VarType(Whitespace) = VBA.vbString Then
                    json_Indentation = VBA.String$(json_CurrentIndentation, Whitespace)
                Else
                    json_Indentation = VBA.Space$(json_CurrentIndentation * Whitespace)
                End If
            End If

            json_BufferAppend json_Buffer, json_Indentation & "]", json_BufferPosition, json_BufferLength
        End If

        ConvertToJson = json_BufferToString(json_Buffer, json_BufferPosition)
    Case VBA.vbInteger, VBA.vbLong, VBA.vbSingle, VBA.vbDouble, VBA.vbCurrency, VBA.vbDecimal
        ' Number (use decimals for numbers)
        ConvertToJson = VBA.Replace(JsonValue, ",", ".")
    Case Else
        ' vbEmpty, vbError, vbDataObject, vbByte, vbUserDefinedType
        ' Use VBA's built-in to-string
        On Error Resume Next
        ConvertToJson = JsonValue
        On Error GoTo 0
    End Select
End Function

' ============================================= '
' Private Functions
' ============================================= '

Private Function json_ParseObject(json_String As String, ByRef json_Index As Long) As Dictionary
    Dim json_Key As String
    Dim json_NextChar As String

    Set json_ParseObject = New Dictionary
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "{" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '{'")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "}" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_Key = json_ParseKey(json_String, json_Index)
            json_NextChar = json_Peek(json_String, json_Index)
            If json_NextChar = "[" Or json_NextChar = "{" Then
                Set json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            Else
                json_ParseObject.Item(json_Key) = json_ParseValue(json_String, json_Index)
            End If
        Loop
    End If
End Function

Private Function json_ParseArray(json_String As String, ByRef json_Index As Long) As Collection
    Set json_ParseArray = New Collection

    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> "[" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '['")
    Else
        json_Index = json_Index + 1

        Do
            json_SkipSpaces json_String, json_Index
            If VBA.Mid$(json_String, json_Index, 1) = "]" Then
                json_Index = json_Index + 1
                Exit Function
            ElseIf VBA.Mid$(json_String, json_Index, 1) = "," Then
                json_Index = json_Index + 1
                json_SkipSpaces json_String, json_Index
            End If

            json_ParseArray.Add json_ParseValue(json_String, json_Index)
        Loop
    End If
End Function

Private Function json_ParseValue(json_String As String, ByRef json_Index As Long) As Variant
    json_SkipSpaces json_String, json_Index
    Select Case VBA.Mid$(json_String, json_Index, 1)
    Case "{"
        Set json_ParseValue = json_ParseObject(json_String, json_Index)
    Case "["
        Set json_ParseValue = json_ParseArray(json_String, json_Index)
    Case """", "'"
        json_ParseValue = json_ParseString(json_String, json_Index)
    Case Else
        If VBA.Mid$(json_String, json_Index, 4) = "true" Then
            json_ParseValue = True
            json_Index = json_Index + 4
        ElseIf VBA.Mid$(json_String, json_Index, 5) = "false" Then
            json_ParseValue = False
            json_Index = json_Index + 5
        ElseIf VBA.Mid$(json_String, json_Index, 4) = "null" Then
            json_ParseValue = Null
            json_Index = json_Index + 4
        ElseIf VBA.InStr("+-0123456789", VBA.Mid$(json_String, json_Index, 1)) Then
            json_ParseValue = json_ParseNumber(json_String, json_Index)
        Else
            Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['")
        End If
    End Select
End Function

Private Function json_ParseString(json_String As String, ByRef json_Index As Long) As String
    Dim json_Quote As String
    Dim json_Char As String
    Dim json_Code As String
    Dim json_Buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long

    json_SkipSpaces json_String, json_Index

    ' Store opening quote to look for matching closing quote
    json_Quote = VBA.Mid$(json_String, json_Index, 1)
    json_Index = json_Index + 1

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        Select Case json_Char
        Case "\"
            ' Escaped string, \\, or \/
            json_Index = json_Index + 1
            json_Char = VBA.Mid$(json_String, json_Index, 1)

            Select Case json_Char
            Case """", "\", "/", "'"
                json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "b"
                json_BufferAppend json_Buffer, vbBack, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "f"
                json_BufferAppend json_Buffer, vbFormFeed, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "n"
                json_BufferAppend json_Buffer, vbCrLf, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "r"
                json_BufferAppend json_Buffer, vbCr, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "t"
                json_BufferAppend json_Buffer, vbTab, json_BufferPosition, json_BufferLength
                json_Index = json_Index + 1
            Case "u"
                ' Unicode character escape (e.g. \u00a9 = Copyright)
                json_Index = json_Index + 1
                json_Code = VBA.Mid$(json_String, json_Index, 4)
                json_BufferAppend json_Buffer, VBA.ChrW(VBA.Val("&h" + json_Code)), json_BufferPosition, json_BufferLength
                json_Index = json_Index + 4
            End Select
        Case json_Quote
            json_ParseString = json_BufferToString(json_Buffer, json_BufferPosition)
            json_Index = json_Index + 1
            Exit Function
        Case Else
            json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
            json_Index = json_Index + 1
        End Select
    Loop
End Function

Private Function json_ParseNumber(json_String As String, ByRef json_Index As Long) As Variant
    Dim json_Char As String
    Dim json_Value As String
    Dim json_IsLargeNumber As Boolean

    json_SkipSpaces json_String, json_Index

    Do While json_Index > 0 And json_Index <= Len(json_String)
        json_Char = VBA.Mid$(json_String, json_Index, 1)

        If VBA.InStr("+-0123456789.eE", json_Char) Then
            ' Unlikely to have massive number, so use simple append rather than buffer here
            json_Value = json_Value & json_Char
            json_Index = json_Index + 1
        Else
            ' Excel only stores 15 significant digits, so any numbers larger than that are truncated
            ' This can lead to issues when BIGINT's are used (e.g. for Ids or Credit Cards), as they will be invalid above 15 digits
            ' See: http://support.microsoft.com/kb/269370
            '
            ' Fix: Parse -> String, Convert -> String longer than 15/16 characters containing only numbers and decimal points -> Number
            ' (decimal doesn't factor into significant digit count, so if present check for 15 digits + decimal = 16)
            json_IsLargeNumber = IIf(InStr(json_Value, "."), Len(json_Value) >= 17, Len(json_Value) >= 16)
            If Not JsonOptions.UseDoubleForLargeNumbers And json_IsLargeNumber Then
                json_ParseNumber = json_Value
            Else
                ' VBA.Val does not use regional settings, so guard for comma is not needed
                json_ParseNumber = VBA.Val(json_Value)
            End If
            Exit Function
        End If
    Loop
End Function

Private Function json_ParseKey(json_String As String, ByRef json_Index As Long) As String
    ' Parse key with single or double quotes
    If VBA.Mid$(json_String, json_Index, 1) = """" Or VBA.Mid$(json_String, json_Index, 1) = "'" Then
        json_ParseKey = json_ParseString(json_String, json_Index)
    ElseIf JsonOptions.AllowUnquotedKeys Then
        Dim json_Char As String
        Do While json_Index > 0 And json_Index <= Len(json_String)
            json_Char = VBA.Mid$(json_String, json_Index, 1)
            If (json_Char <> " ") And (json_Char <> ":") Then
                json_ParseKey = json_ParseKey & json_Char
                json_Index = json_Index + 1
            Else
                Exit Do
            End If
        Loop
    Else
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting '""' or '''")
    End If

    ' Check for colon and skip if present or throw if not present
    json_SkipSpaces json_String, json_Index
    If VBA.Mid$(json_String, json_Index, 1) <> ":" Then
        Err.Raise 10001, "JSONConverter", json_ParseErrorMessage(json_String, json_Index, "Expecting ':'")
    Else
        json_Index = json_Index + 1
    End If
End Function

Private Function json_IsUndefined(ByVal json_Value As Variant) As Boolean
    ' Empty / Nothing -> undefined
    Select Case VBA.VarType(json_Value)
    Case VBA.vbEmpty
        json_IsUndefined = True
    Case VBA.vbObject
        Select Case VBA.TypeName(json_Value)
        Case "Empty", "Nothing"
            json_IsUndefined = True
        End Select
    End Select
End Function

Private Function json_Encode(ByVal json_Text As Variant) As String
    ' Reference: http://www.ietf.org/rfc/rfc4627.txt
    ' Escape: ", \, /, backspace, form feed, line feed, carriage return, tab
    Dim json_Index As Long
    Dim json_Char As String
    Dim json_AscCode As Long
    Dim json_Buffer As String
    Dim json_BufferPosition As Long
    Dim json_BufferLength As Long

    For json_Index = 1 To VBA.Len(json_Text)
        json_Char = VBA.Mid$(json_Text, json_Index, 1)
        json_AscCode = VBA.AscW(json_Char)

        ' When AscW returns a negative number, it returns the twos complement form of that number.
        ' To convert the twos complement notation into normal binary notation, add 0xFFF to the return result.
        ' https://support.microsoft.com/en-us/kb/272138
        If json_AscCode < 0 Then
            json_AscCode = json_AscCode + 65536
        End If

        ' From spec, ", \, and control characters must be escaped (solidus is optional)

        Select Case json_AscCode
        Case 34
            ' " -> 34 -> \"
            json_Char = "\"""
        Case 92
            ' \ -> 92 -> \\
            json_Char = "\\"
        Case 47
            ' / -> 47 -> \/ (optional)
            If JsonOptions.EscapeSolidus Then
                json_Char = "\/"
            End If
        Case 8
            ' backspace -> 8 -> \b
            json_Char = "\b"
        Case 12
            ' form feed -> 12 -> \f
            json_Char = "\f"
        Case 10
            ' line feed -> 10 -> \n
            json_Char = "\n"
        Case 13
            ' carriage return -> 13 -> \r
            json_Char = "\r"
        Case 9
            ' tab -> 9 -> \t
            json_Char = "\t"
        Case 0 To 31, 127 To 65535
            ' Non-ascii characters -> convert to 4-digit hex
            json_Char = "\u" & VBA.Right$("0000" & VBA.Hex$(json_AscCode), 4)
        End Select

        json_BufferAppend json_Buffer, json_Char, json_BufferPosition, json_BufferLength
    Next json_Index

    json_Encode = json_BufferToString(json_Buffer, json_BufferPosition)
End Function

Private Function json_Peek(json_String As String, ByVal json_Index As Long, Optional json_NumberOfCharacters As Long = 1) As String
    ' "Peek" at the next number of characters without incrementing json_Index (ByVal instead of ByRef)
    json_SkipSpaces json_String, json_Index
    json_Peek = VBA.Mid$(json_String, json_Index, json_NumberOfCharacters)
End Function

Private Sub json_SkipSpaces(json_String As String, ByRef json_Index As Long)
    ' Increment index to skip over spaces
    Do While json_Index > 0 And json_Index <= VBA.Len(json_String) And VBA.Mid$(json_String, json_Index, 1) = " "
        json_Index = json_Index + 1
    Loop
End Sub

Private Function json_StringIsLargeNumber(json_String As Variant) As Boolean
    ' Check if the given string is considered a "large number"
    ' (See json_ParseNumber)

    Dim json_Length As Long
    Dim json_CharIndex As Long
    json_Length = VBA.Len(json_String)

    ' Length with be at least 16 characters and assume will be less than 100 characters
    If json_Length >= 16 And json_Length <= 100 Then
        Dim json_CharCode As String

        json_StringIsLargeNumber = True

        For json_CharIndex = 1 To json_Length
            json_CharCode = VBA.Asc(VBA.Mid$(json_String, json_CharIndex, 1))
            Select Case json_CharCode
            ' Look for .|0-9|E|e
            Case 46, 48 To 57, 69, 101
                ' Continue through characters
            Case Else
                json_StringIsLargeNumber = False
                Exit Function
            End Select
        Next json_CharIndex
    End If
End Function

Private Function json_ParseErrorMessage(json_String As String, ByRef json_Index As Long, ErrorMessage As String)
    ' Provide detailed parse error message, including details of where and what occurred
    '
    ' Example:
    ' Error parsing JSON:
    ' {"abcde":True}
    '          ^
    ' Expecting 'STRING', 'NUMBER', null, true, false, '{', or '['

    Dim json_StartIndex As Long
    Dim json_StopIndex As Long

    ' Include 10 characters before and after error (if possible)
    json_StartIndex = json_Index - 10
    json_StopIndex = json_Index + 10
    If json_StartIndex <= 0 Then
        json_StartIndex = 1
    End If
    If json_StopIndex > VBA.Len(json_String) Then
        json_StopIndex = VBA.Len(json_String)
    End If

    json_ParseErrorMessage = "Error parsing JSON:" & VBA.vbNewLine & _
                             VBA.Mid$(json_String, json_StartIndex, json_StopIndex - json_StartIndex + 1) & VBA.vbNewLine & _
                             VBA.Space$(json_Index - json_StartIndex) & "^" & VBA.vbNewLine & _
                             ErrorMessage
End Function

Private Sub json_BufferAppend(ByRef json_Buffer As String, _
                              ByRef json_Append As Variant, _
                              ByRef json_BufferPosition As Long, _
                              ByRef json_BufferLength As Long)
    ' VBA can be slow to append strings due to allocating a new string for each append
    ' Instead of using the traditional append, allocate a large empty string and then copy string at append position
    '
    ' Example:
    ' Buffer: "abc  "
    ' Append: "def"
    ' Buffer Position: 3
    ' Buffer Length: 5
    '
    ' Buffer position + Append length > Buffer length -> Append chunk of blank space to buffer
    ' Buffer: "abc       "
    ' Buffer Length: 10
    '
    ' Put "def" into buffer at position 3 (0-based)
    ' Buffer: "abcdef    "
    '
    ' Approach based on cStringBuilder from vbAccelerator
    ' http://www.vbaccelerator.com/home/VB/Code/Techniques/RunTime_Debug_Tracing/VB6_Tracer_Utility_zip_cStringBuilder_cls.asp
    '
    ' and clsStringAppend from Philip Swannell
    ' https://github.com/VBA-tools/VBA-JSON/pull/82

    Dim json_AppendLength As Long
    Dim json_LengthPlusPosition As Long

    json_AppendLength = VBA.Len(json_Append)
    json_LengthPlusPosition = json_AppendLength + json_BufferPosition

    If json_LengthPlusPosition > json_BufferLength Then
        ' Appending would overflow buffer, add chunk
        ' (double buffer length or append length, whichever is bigger)
        Dim json_AddedLength As Long
        json_AddedLength = IIf(json_AppendLength > json_BufferLength, json_AppendLength, json_BufferLength)

        json_Buffer = json_Buffer & VBA.Space$(json_AddedLength)
        json_BufferLength = json_BufferLength + json_AddedLength
    End If

    ' Note: Namespacing with VBA.Mid$ doesn't work properly here, throwing compile error:
    ' Function call on left-hand side of assignment must return Variant or Object
    Mid$(json_Buffer, json_BufferPosition + 1, json_AppendLength) = CStr(json_Append)
    json_BufferPosition = json_BufferPosition + json_AppendLength
End Sub

Private Function json_BufferToString(ByRef json_Buffer As String, ByVal json_BufferPosition As Long) As String
    If json_BufferPosition > 0 Then
        json_BufferToString = VBA.Left$(json_Buffer, json_BufferPosition)
    End If
End Function

''
' VBA-UTC v1.0.6
' (c) Tim Hall - https://github.com/VBA-tools/VBA-UtcConverter
'
' UTC/ISO 8601 Converter for VBA
'
' Errors:
' 10011 - UTC parsing error
' 10012 - UTC conversion error
' 10013 - ISO 8601 parsing error
' 10014 - ISO 8601 conversion error
'
' @module UtcConverter
' @author tim.hall.engr@gmail.com
' @license MIT (http://www.opensource.org/licenses/mit-license.php)
'' ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ '

' (Declarations moved to top)

' ============================================= '
' Public Methods
' ============================================= '

''
' Parse UTC date to local date
'
' @method ParseUtc
' @param {Date} UtcDate
' @return {Date} Local date
' @throws 10011 - UTC parsing error
''
Public Function ParseUtc(utc_UtcDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ParseUtc = utc_ConvertDate(utc_UtcDate)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_LocalDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_SystemTimeToTzSpecificLocalTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_UtcDate), utc_LocalDate

    ParseUtc = utc_SystemTimeToDate(utc_LocalDate)
#End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10011, "UtcConverter.ParseUtc", "UTC parsing error: " & Err.Number & " - " & Err.description
End Function

''
' Convert local date to UTC date
'
' @method ConvertToUrc
' @param {Date} utc_LocalDate
' @return {Date} UTC date
' @throws 10012 - UTC conversion error
''
Public Function ConvertToUtc(utc_LocalDate As Date) As Date
    On Error GoTo utc_ErrorHandling

#If Mac Then
    ConvertToUtc = utc_ConvertDate(utc_LocalDate, utc_ConvertToUtc:=True)
#Else
    Dim utc_TimeZoneInfo As utc_TIME_ZONE_INFORMATION
    Dim utc_UtcDate As utc_SYSTEMTIME

    utc_GetTimeZoneInformation utc_TimeZoneInfo
    utc_TzSpecificLocalTimeToSystemTime utc_TimeZoneInfo, utc_DateToSystemTime(utc_LocalDate), utc_UtcDate

    ConvertToUtc = utc_SystemTimeToDate(utc_UtcDate)
#End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10012, "UtcConverter.ConvertToUtc", "UTC conversion error: " & Err.Number & " - " & Err.description
End Function

''
' Parse ISO 8601 date string to local date
'
' @method ParseIso
' @param {Date} utc_IsoString
' @return {Date} Local date
' @throws 10013 - ISO 8601 parsing error
''
Public Function ParseIso(utc_IsoString As String) As Date
    On Error GoTo utc_ErrorHandling

    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String
    Dim utc_OffsetIndex As Long
    Dim utc_HasOffset As Boolean
    Dim utc_NegativeOffset As Boolean
    Dim utc_OffsetParts() As String
    Dim utc_Offset As Date

    utc_Parts = VBA.Split(utc_IsoString, "T")
    utc_DateParts = VBA.Split(utc_Parts(0), "-")
    ParseIso = VBA.DateSerial(VBA.CInt(utc_DateParts(0)), VBA.CInt(utc_DateParts(1)), VBA.CInt(utc_DateParts(2)))

    If UBound(utc_Parts) > 0 Then
        If VBA.InStr(utc_Parts(1), "Z") Then
            utc_TimeParts = VBA.Split(VBA.Replace(utc_Parts(1), "Z", ""), ":")
        Else
            utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "+")
            If utc_OffsetIndex = 0 Then
                utc_NegativeOffset = True
                utc_OffsetIndex = VBA.InStr(1, utc_Parts(1), "-")
            End If

            If utc_OffsetIndex > 0 Then
                utc_HasOffset = True
                utc_TimeParts = VBA.Split(VBA.Left$(utc_Parts(1), utc_OffsetIndex - 1), ":")
                utc_OffsetParts = VBA.Split(VBA.Right$(utc_Parts(1), Len(utc_Parts(1)) - utc_OffsetIndex), ":")

                Select Case UBound(utc_OffsetParts)
                Case 0
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), 0, 0)
                Case 1
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), 0)
                Case 2
                    ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
                    utc_Offset = TimeSerial(VBA.CInt(utc_OffsetParts(0)), VBA.CInt(utc_OffsetParts(1)), Int(VBA.Val(utc_OffsetParts(2))))
                End Select

                If utc_NegativeOffset Then: utc_Offset = -utc_Offset
            Else
                utc_TimeParts = VBA.Split(utc_Parts(1), ":")
            End If
        End If

        Select Case UBound(utc_TimeParts)
        Case 0
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), 0, 0)
        Case 1
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), 0)
        Case 2
            ' VBA.Val does not use regional settings, use for seconds to avoid decimal/comma issues
            ParseIso = ParseIso + VBA.TimeSerial(VBA.CInt(utc_TimeParts(0)), VBA.CInt(utc_TimeParts(1)), Int(VBA.Val(utc_TimeParts(2))))
        End Select

        ParseIso = ParseUtc(ParseIso)

        If utc_HasOffset Then
            ParseIso = ParseIso - utc_Offset
        End If
    End If

    Exit Function

utc_ErrorHandling:
    Err.Raise 10013, "UtcConverter.ParseIso", "ISO 8601 parsing error for " & utc_IsoString & ": " & Err.Number & " - " & Err.description
End Function

''
' Convert local date to ISO 8601 string
'
' @method ConvertToIso
' @param {Date} utc_LocalDate
' @return {Date} ISO 8601 string
' @throws 10014 - ISO 8601 conversion error
''
Public Function ConvertToIso(utc_LocalDate As Date) As String
    On Error GoTo utc_ErrorHandling

    ConvertToIso = VBA.Format$(ConvertToUtc(utc_LocalDate), "yyyy-mm-ddTHH:mm:ss.000Z")

    Exit Function

utc_ErrorHandling:
    Err.Raise 10014, "UtcConverter.ConvertToIso", "ISO 8601 conversion error: " & Err.Number & " - " & Err.description
End Function

' ============================================= '
' Private Functions
' ============================================= '

#If Mac Then

Private Function utc_ConvertDate(utc_Value As Date, Optional utc_ConvertToUtc As Boolean = False) As Date
    Dim utc_ShellCommand As String
    Dim utc_Result As utc_ShellResult
    Dim utc_Parts() As String
    Dim utc_DateParts() As String
    Dim utc_TimeParts() As String

    If utc_ConvertToUtc Then
        utc_ShellCommand = "date -ur `date -jf '%Y-%m-%d %H:%M:%S' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & "' " & _
            " +'%s'` +'%Y-%m-%d %H:%M:%S'"
    Else
        utc_ShellCommand = "date -jf '%Y-%m-%d %H:%M:%S %z' " & _
            "'" & VBA.Format$(utc_Value, "yyyy-mm-dd HH:mm:ss") & " +0000' " & _
            "+'%Y-%m-%d %H:%M:%S'"
    End If

    utc_Result = utc_ExecuteInShell(utc_ShellCommand)

    If utc_Result.utc_Output = "" Then
        Err.Raise 10015, "UtcConverter.utc_ConvertDate", "'date' command failed"
    Else
        utc_Parts = Split(utc_Result.utc_Output, " ")
        utc_DateParts = Split(utc_Parts(0), "-")
        utc_TimeParts = Split(utc_Parts(1), ":")

        utc_ConvertDate = DateSerial(utc_DateParts(0), utc_DateParts(1), utc_DateParts(2)) + _
            TimeSerial(utc_TimeParts(0), utc_TimeParts(1), utc_TimeParts(2))
    End If
End Function

Private Function utc_ExecuteInShell(utc_ShellCommand As String) As utc_ShellResult
#If VBA7 Then
    Dim utc_File As LongPtr
    Dim utc_Read As LongPtr
#Else
    Dim utc_File As Long
    Dim utc_Read As Long
#End If

    Dim utc_Chunk As String

    On Error GoTo utc_ErrorHandling
    utc_File = utc_popen(utc_ShellCommand, "r")

    If utc_File = 0 Then: Exit Function

    Do While utc_feof(utc_File) = 0
        utc_Chunk = VBA.Space$(50)
        utc_Read = CLng(utc_fread(utc_Chunk, 1, Len(utc_Chunk) - 1, utc_File))
        If utc_Read > 0 Then
            utc_Chunk = VBA.Left$(utc_Chunk, CLng(utc_Read))
            utc_ExecuteInShell.utc_Output = utc_ExecuteInShell.utc_Output & utc_Chunk
        End If
    Loop

utc_ErrorHandling:
    utc_ExecuteInShell.utc_ExitCode = CLng(utc_pclose(utc_File))
End Function

#Else

Private Function utc_DateToSystemTime(utc_Value As Date) As utc_SYSTEMTIME
    utc_DateToSystemTime.utc_wYear = VBA.Year(utc_Value)
    utc_DateToSystemTime.utc_wMonth = VBA.Month(utc_Value)
    utc_DateToSystemTime.utc_wDay = VBA.Day(utc_Value)
    utc_DateToSystemTime.utc_wHour = VBA.Hour(utc_Value)
    utc_DateToSystemTime.utc_wMinute = VBA.Minute(utc_Value)
    utc_DateToSystemTime.utc_wSecond = VBA.Second(utc_Value)
    utc_DateToSystemTime.utc_wMilliseconds = 0
End Function

Private Function utc_SystemTimeToDate(utc_Value As utc_SYSTEMTIME) As Date
    utc_SystemTimeToDate = DateSerial(utc_Value.utc_wYear, utc_Value.utc_wMonth, utc_Value.utc_wDay) + _
        TimeSerial(utc_Value.utc_wHour, utc_Value.utc_wMinute, utc_Value.utc_wSecond)
End Function

#End If
-------------------------------------------------------------------------------
VBA MACRO modDatabase.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/modDatabase'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: modDatabase (Standard Module)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 20-12-24
' PURPOSE: Database abstraction layer providing a unified interface for cable
'          and endpoint management across all plant types. Acts as a facade
'          pattern to coordinate operations between forms and plant-specific
'          worksheet modules (sht_Data, sht_WetPlant, sht_OreSorter, sht_Retreatment).
' ==============================================================================

Option Explicit

' ==============================================================================
' ENUMERATIONS - DATA VALIDATION AND ERROR HANDLING
' ==============================================================================

' Defines which cable fields are required during validation
' All values set to True indicating mandatory fields
Enum eCableColumnsRequired
    ccrCableID = True           ' Cable identifier must be provided
    ccrSource = True            ' Source endpoint must be specified
    ccrDestination = True       ' Destination endpoint must be specified
    ccrCoreSize = True          ' Core wire size must be specified
    ccrEarthSize = True         ' Earth wire size must be specified
    ccrCoreConfig = True        ' Core configuration must be specified
    ccrCableType = True         ' Cable type must be specified
    ccrInsulationType = True    ' Insulation type must be specified
    ccrCableLength = True       ' Cable length must be specified
End Enum

' Defines which endpoint fields are required during validation
' All values set to True indicating mandatory fields
Enum eEndpointColumnsRequired
    ecrShortName = True         ' Endpoint short name must be provided
    ecrDescription = True       ' Endpoint description must be provided
End Enum

' Standard error codes for function return values
' Currently only defines a single error state
Enum eErrorCodes
    ecError = 0                 ' Indicates an error occurred (zero/false)
End Enum

' ==============================================================================
' PUBLIC SUBROUTINES - SYSTEM MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: Refresh
' PURPOSE: Refreshes all plant form data by calling each worksheet's load method
' NOTES: Coordinates data refresh across all three plant types
'        Uses worksheet code names for reliable reference
'------------------------------------------------------------------------------
Public Sub Refresh()
    On Error GoTo ErrorHandler
    
    ' Refresh data for all three plant types by calling their respective load methods
    Call Worksheets("Crushing Wet Screen Plant").LoadCWSPForm
    Call Worksheets("Ore Sorting Plant").LoadOSPForm
    Call Worksheets("Retreatment Gravity Plant").LoadRGPForm
    
ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    HandleError "modDatabase", "Refresh", Err.Number, Err.description, Erl
    Resume ErrorExit

End Sub

' ==============================================================================
' PUBLIC FUNCTIONS - ENDPOINT MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: GetEndpointTableName
' PURPOSE: Wrapper function to get the table name for a specific plant type
' PARAMETERS: strFormID - Plant type identifier ("WET_PLANT", "ORE_SORTER", "RETREATMENT")
' RETURNS: String - Excel table name for the specified plant type
' NOTES: BUG - Function doesn't return the result from sht_Data.GetEndpointTableName
'------------------------------------------------------------------------------
Public Function GetEndpointTableName(ByVal strFormID As String) As String
On Error GoTo AIError

    ' BUG: Missing assignment - should be:
    ' GetEndpointTableName = sht_Data.GetEndpointTableName(strFormID)
    GetEndpointTableName = sht_Data.GetEndpointTableName(strFormID)

AIExit:
Exit Function

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "modDatabase", "GetEndpointTableName", Err.Number, Err.description, Erl
    Resume AIExit
    
End Function

'------------------------------------------------------------------------------
' FUNCTION: SaveEndpoint
' PURPOSE: Saves a new endpoint record and returns success status
' PARAMETERS: strFormID - Plant type identifier
'            epNewEndpoint - clEndpoint object containing endpoint data
' RETURNS: Boolean - True if save successful, False if failed
' NOTES: Delegates to sht_Data.SaveEndpoint and interprets return value
'        Cleans up object reference regardless of success/failure
'------------------------------------------------------------------------------
Public Function SaveEndpoint(ByVal strFormID As String, epNewEndpoint As clEndpoint) As Boolean
    On Error GoTo ErrorHandler
    
    ' Attempt to save the endpoint and get the new row number
    Dim lngNewRowNumber As Long
    lngNewRowNumber = sht_Data.SaveEndpoint(strFormID, epNewEndpoint)
        
    ' Interpret the result: non-zero return means success
    If Not lngNewRowNumber = eErrorCodes.ecError Then
        SaveEndpoint = True
    Else
        SaveEndpoint = False
    End If
    
    ' Clean up object reference
    Set epNewEndpoint = Nothing
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling with cleanup
    Set epNewEndpoint = Nothing
    HandleError "modDatabase", "SaveEndpoint", Err.Number, Err.description, Erl
    Resume ErrorExit

End Function

'------------------------------------------------------------------------------
' FUNCTION: GetEndpointDescription
' PURPOSE: Retrieves the description for a specified endpoint
' PARAMETERS: strFormID - Plant type identifier
'            strShortName - Short name of the endpoint to find
' RETURNS: String - Description of the endpoint, empty if not found
' NOTES: Simple wrapper around sht_Data.GetEndpointDescription
'        BUG - Error message references wrong function name
'------------------------------------------------------------------------------
Public Function GetEndpointDescription(ByVal strFormID As String, ByVal strShortName As String) As String
    On Error GoTo ErrorHandler
    
    ' Delegate to the data layer for endpoint lookup
    GetEndpointDescription = sht_Data.GetEndpointDescription(strFormID, strShortName)

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling
    ' BUG: Error message should reference "GetEndpointDescription", not "GetNextCircuitNumber"
    HandleError "modDatabase", "GetEndpointDescription", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: getNextEndpointRow
' PURPOSE: Gets the next available row number for endpoint insertion
' PARAMETERS: strFormID - Plant type identifier
' RETURNS: Long - Next available row number
' NOTES: Simple wrapper around sht_Data.getNextEndpointRow
'        Function name uses non-standard camelCase (should be PascalCase)
'------------------------------------------------------------------------------
Public Function getNextEndpointRow(ByVal strFormID As String) As Long
    On Error GoTo ErrorHandler
    
    ' Delegate to the data layer for row calculation
    getNextEndpointRow = sht_Data.getNextEndpointRow(strFormID)
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling
    HandleError "modDatabase", "getNextEndpointRow", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' PUBLIC FUNCTIONS - CABLE MANAGEMENT
' ==============================================================================

'------------------------------------------------------------------------------
' FUNCTION: RegisterCable
' PURPOSE: Saves a new cable record to the appropriate plant-specific table
' PARAMETERS: strFormID - Plant type identifier
'            cNewCable - clCable object containing cable data
' RETURNS: Boolean - True if registration successful, False if failed
' NOTES: Uses Select Case to route to appropriate plant worksheet module
'        Interprets return value to provide boolean success indicator
'------------------------------------------------------------------------------
Public Function RegisterCable(ByVal strFormID As String, _
                                ByVal cNewCable As clCable) As Boolean
    On Error GoTo ErrorHandler
    
    Dim lngNewRowNumber As Long
    
    ' Route the cable save operation to the appropriate plant worksheet
    Select Case strFormID
        Case Is = "WET_PLANT": lngNewRowNumber = sht_WetPlant.SaveCable(cNewCable)
        Case Is = "ORE_SORTER": lngNewRowNumber = sht_OreSorter.SaveCable(cNewCable)
        Case Is = "RETREATMENT": lngNewRowNumber = sht_Retreatment.SaveCable(cNewCable)
    End Select
    
    ' Interpret the result: non-zero return means success
    If Not lngNewRowNumber = eErrorCodes.ecError Then
        RegisterCable = True
    Else
        RegisterCable = False
    End If
    
    ' Clean up object reference
    Set cNewCable = Nothing

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling with cleanup
    Set cNewCable = Nothing
    HandleError "modDatabase", "RegisterCable", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetNextCircuitNumber
' PURPOSE: Polymorphic function to get the next circuit number for any plant type
' PARAMETERS: strFormID - Plant type identifier
' RETURNS: Long - Next sequential circuit number to use
' NOTES: Routes request to appropriate plant worksheet based on form ID
'        Each plant maintains its own circuit numbering sequence
'------------------------------------------------------------------------------
Public Function GetNextCircuitNumber(strFormID As String) As Long
    On Error GoTo ErrorHandler
    
    ' Route the circuit number request to the appropriate plant worksheet
    Select Case strFormID
        Case Is = "WET_PLANT": GetNextCircuitNumber = sht_WetPlant.GetNextCircuitNumber()
        Case Is = "ORE_SORTER": GetNextCircuitNumber = sht_OreSorter.GetNextCircuitNumber()
        Case Is = "RETREATMENT": GetNextCircuitNumber = sht_Retreatment.GetNextCircuitNumber()
    End Select

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling
    HandleError "modDatabase", "GetNextCircuitNumber", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: GetCableByRowIndex
' PURPOSE: Polymorphic function to retrieve a cable from any plant type
' PARAMETERS: strFormID - Plant type identifier
'            lngRowIndex - The row index in the plant's ListRows collection (1-based)
' RETURNS: clCable object - Cable data from specified row, or Nothing if invalid
' NOTES: Routes request to appropriate plant worksheet based on form ID
'------------------------------------------------------------------------------
Public Function GetCableByRowIndex(strFormID As String, lngRowIndex As Long) As clCable
    On Error GoTo ErrorHandler
    
    Dim cCable As clCable
    
    ' Route the cable retrieval request to the appropriate plant worksheet
    Select Case strFormID
        Case Is = "WET_PLANT"
            Set cCable = sht_WetPlant.GetCableByRowIndex(lngRowIndex)
        Case Is = "ORE_SORTER"
            Set cCable = sht_OreSorter.GetCableByRowIndex(lngRowIndex)
        Case Is = "RETREATMENT"
            Set cCable = sht_Retreatment.GetCableByRowIndex(lngRowIndex)
        Case Else
            Set cCable = Nothing
    End Select
    
    Set GetCableByRowIndex = cCable

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling
    HandleError "modDatabase", "GetCableByRowIndex", Err.Number, Err.description, Erl
    Set GetCableByRowIndex = Nothing
    Resume ErrorExit
End Function

'------------------------------------------------------------------------------
' FUNCTION: UpdateCable
' PURPOSE: Polymorphic function to update a cable in any plant type
' PARAMETERS: strFormID - Plant type identifier
'            lngRowIndex - The row index in the plant's ListRows collection (1-based)
'            cUpdatedCable - clCable object containing the updated cable data
' RETURNS: Boolean - True if update successful, False if failed
' NOTES: Routes request to appropriate plant worksheet based on form ID
'------------------------------------------------------------------------------
Public Function UpdateCable(strFormID As String, lngRowIndex As Long, cUpdatedCable As clCable) As Boolean
    On Error GoTo ErrorHandler
    
    Dim bSuccess As Boolean
    
    ' Route the cable update request to the appropriate plant worksheet
    Select Case strFormID
        Case Is = "WET_PLANT"
            bSuccess = sht_WetPlant.UpdateCable(lngRowIndex, cUpdatedCable)
        Case Is = "ORE_SORTER"
            bSuccess = sht_OreSorter.UpdateCable(lngRowIndex, cUpdatedCable)
        Case Is = "RETREATMENT"
            bSuccess = sht_Retreatment.UpdateCable(lngRowIndex, cUpdatedCable)
        Case Else
            bSuccess = False
    End Select
    
    UpdateCable = bSuccess
    
    ' Clean up object reference
    Set cUpdatedCable = Nothing

ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling with cleanup
    Set cUpdatedCable = Nothing
    HandleError "modDatabase", "UpdateCable", Err.Number, Err.description, Erl
    UpdateCable = False
    Resume ErrorExit
End Function
-------------------------------------------------------------------------------
VBA MACRO ModAppState.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/ModAppState'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Option Explicit

' Non-invasive helpers to make long routines faster and safer.
' Use like:
'   Dim s As AppState: s = BeginFastMode()
'   ' ...work...
'   EndFastMode s
'
' Always pair Begin/End in the same scope and ensure EndFastMode runs even on error.

Public Type AppState
    ScreenUpdating As Boolean
    EnableEvents As Boolean
    Calculation As XlCalculation
End Type

Public Function BeginFastMode() As AppState
    With Application
        BeginFastMode.ScreenUpdating = .ScreenUpdating
        BeginFastMode.EnableEvents = .EnableEvents
        BeginFastMode.Calculation = .Calculation
        .ScreenUpdating = False
        .EnableEvents = False
        .Calculation = xlCalculationManual
    End With
End Function

Public Sub EndFastMode(ByRef state As AppState)
    With Application
        .ScreenUpdating = state.ScreenUpdating
        .EnableEvents = state.EnableEvents
        .Calculation = state.Calculation
    End With
End Sub
-------------------------------------------------------------------------------
VBA MACRO ModError.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/ModError'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Option Explicit

' Centralized error handling. Preserves behavior by logging and exiting the procedure.
' Toggle these constants as needed.
Private Const SHOW_MSG As Boolean = True    ' True to show MsgBox on errors
Private Const LOG_TO_IMMEDIATE As Boolean = True

Public Sub HandleError(ByVal moduleName As String, ByVal procName As String, _
                       ByVal errNum As Long, ByVal errDesc As String, ByVal errLine As Long)
    On Error Resume Next
    
    Dim stamp As String
    stamp = Format$(Now, "yyyy-mm-dd hh:nn:ss")
    
    Dim msg As String
    msg = stamp & " [" & moduleName & "." & procName & "] Error " & errNum & _
          " (Line " & errLine & "): " & errDesc
          
    If LOG_TO_IMMEDIATE Then Debug.Print msg
    If SHOW_MSG Then MsgBox msg, vbExclamation, "VBA Error"
    
End Sub
-------------------------------------------------------------------------------
VBA MACRO modUDT.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/modUDT'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' Author: jorr@mtcarbine.com.au
' Date 24-12-24
Option Explicit

Type Endpoint
    strEndpointShortName As String
    strEndpointDescription As String
End Type

-------------------------------------------------------------------------------
VBA MACRO frm_RegisterEndpoint.frm 
in file: xl/vbaProject.bin - OLE stream: 'VBA/frm_RegisterEndpoint'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ==============================================================================
' MODULE: frm_RegisterEndpoint (UserForm)
' AUTHOR: jorr@mtcarbine.com.au
' DATE: 23-12-24
' PURPOSE: UserForm for creating new endpoints across different plant types.
'          Provides a unified interface for registering Wet Plant, Ore Sorter,
'          and Retreatment endpoints with plant-specific theming and validation.
'          Integrates with the endpoint management system in sht_Data.
' ==============================================================================

Option Explicit

' ==============================================================================
' MODULE-LEVEL VARIABLES
' ==============================================================================

' Stores the plant type identifier for the current form session
' Valid values: "WET_PLANT", "ORE_SORTER", "RETREATMENT"
Dim ID_NEW_CAB_FORM As String

' ==============================================================================
' USERFORM EVENT HANDLERS
' ==============================================================================

'------------------------------------------------------------------------------
' EVENT HANDLER: UserForm_Activate
' PURPOSE: Configures the form appearance and content based on plant type
' NOTES: Sets color scheme, title, and regex pattern help text specific to
'        each plant type. Uses RGB color codes for visual plant identification.
'------------------------------------------------------------------------------
Private Sub UserForm_Activate()
    On Error GoTo ErrorHandler
    
    Dim rEndpoints As Range  ' Currently unused but may be for future functionality
    
    ' Get the plant type identifier from the hidden form field
    ID_NEW_CAB_FORM = Me.txt_FormID
    
    ' Configure form appearance based on plant type
    If StrComp(ID_NEW_CAB_FORM, "WET_PLANT", vbTextCompare) = 0 Then
        ' Wet Plant color scheme: Dark blue theme
        Me.lbl_Spacer1.BackColor = RGB(15, 60, 82)   ' Dark blue headers
        Me.lbl_Spacer2.BackColor = RGB(15, 60, 82)
        Me.lbl_Title.BackColor = RGB(15, 60, 82)
        Me.BackColor = RGB(40, 40, 40)               ' Dark gray background
        Me.lbl_Title.caption = "Register Wet Plant Endpoint"
        Me.lbl_Help.caption = "[A-Z]{2,3}[1][0-1][0-9]"  ' Regex pattern with "1" for Wet Plant
    
    ElseIf StrComp(ID_NEW_CAB_FORM, "ORE_SORTER", vbTextCompare) = 0 Then
        ' Ore Sorter color scheme: Teal theme
        Me.lbl_Spacer1.BackColor = RGB(0, 40, 40)    ' Dark teal headers
        Me.lbl_Spacer2.BackColor = RGB(0, 40, 40)
        Me.lbl_Title.BackColor = RGB(0, 40, 40)
        Me.BackColor = RGB(0, 80, 80)                ' Teal background
        Me.lbl_Title.caption = "Register Ore Sorter Endpoint"
        Me.lbl_Help.caption = "[A-Z]{2,3}[2][0-1][0-9]"  ' Regex pattern with "2" for Ore Sorter
    
    ElseIf StrComp(ID_NEW_CAB_FORM, "RETREATMENT", vbTextCompare) = 0 Then
        ' Retreatment color scheme: Gray/red theme
        Me.lbl_Spacer1.BackColor = RGB(80, 80, 80)   ' Gray headers
        Me.lbl_Spacer2.BackColor = RGB(80, 80, 80)
        Me.lbl_Title.BackColor = RGB(80, 80, 80)
        Me.BackColor = RGB(80, 40, 40)               ' Dark red background
        Me.lbl_Title.caption = "Register Retreatment Endpoint"
        Me.lbl_Help.caption = "[A-Z]{2,3}[3][0-1][0-9]"  ' Regex pattern with "3" for Retreatment
    
    End If
    
ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "UserForm_Activate", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: UserForm_Deactivate
' PURPOSE: Updates the cable registration form's combo box when this form closes
' NOTES: Ensures the cable form has the latest endpoint data when user returns
'        Uses modDatabase wrapper function for table name lookup
'------------------------------------------------------------------------------
Private Sub UserForm_Deactivate()
On Error GoTo AIError

    ' Update the cable registration form's endpoint combo box with latest data
    frm_RegisterCable.UpdateComboBox (modDatabase.GetEndpointTableName(Me.txt_FormID))

AIExit:
Exit Sub

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "frm_RegisterEndpoint", "UserForm_Deactivate", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: UserForm_Initialize
' PURPOSE: Performs initial form setup and UI adjustments
' NOTES: Minor UI tweak to align label with text box for better appearance
'------------------------------------------------------------------------------
Private Sub UserForm_Initialize()
    On Error GoTo ErrorHandler
    
    ' Fine-tune UI positioning: move help label up slightly to align with text box
    Me.lbl_Help.Top = Me.lbl_Help.Top + 3

ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "UserForm_Initialize", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

' ==============================================================================
' PUBLIC METHODS
' ==============================================================================

'------------------------------------------------------------------------------
' SUBROUTINE: Clear
' PURPOSE: Resets all form input fields to empty state
' NOTES: Used by "Save & Continue" functionality to prepare form for next entry
'        Could be enhanced to clear any additional fields added in future
'------------------------------------------------------------------------------
Public Sub Clear()
    On Error GoTo ErrorHandler
    
    ' Reset all input fields to blank state
    Me.txt_EndpointShortName = ""
    Me.txt_EndpointDescription = ""

ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "Clear", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' FUNCTION: ValidateRequired
' PURPOSE: Validates that all required fields have been completed
' RETURNS: Boolean - True if validation passes, False if any field is missing
' NOTES: Contains potential logic error in validation conditions - see comments below
'        Provides user feedback via message boxes for validation failures
'------------------------------------------------------------------------------
Public Function ValidateRequired() As Boolean
    On Error GoTo ErrorHandler

    ' POTENTIAL BUG: The validation logic appears incorrect
    ' Current: (Me.txt_EndpointShortName.Value = "") = ecrShortName
    ' This compares a boolean (empty check) with an enum value (ecrShortName)
    ' Should likely be: If Len(Trim(Me.txt_EndpointShortName.Value)) = 0 Then
    
    If Len(Trim(Me.txt_EndpointShortName.Value)) = 0 Then
        MsgBox "Short Name is required."
        ValidateRequired = False
        Exit Function
    
    ElseIf Len(Trim(Me.txt_EndpointDescription.Value)) = 0 Then
        MsgBox "Description is required."
        ValidateRequired = False
        Exit Function
        
    End If
    
    ' All validation passed
    ValidateRequired = True
    
ErrorExit:
Exit Function

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "ValidateRequired", Err.Number, Err.description, Erl
    Resume ErrorExit
End Function

' ==============================================================================
' COMMAND BUTTON EVENT HANDLERS
' ==============================================================================

'------------------------------------------------------------------------------
' EVENT HANDLER: cmd_Cancel_Click
' PURPOSE: Handles cancel button click - closes form without saving
' NOTES: Simple form closure with error handling
'------------------------------------------------------------------------------
Private Sub cmd_Cancel_Click()
On Error GoTo AIError

    ' Close the form without saving any data
    Unload Me

AIExit:
Exit Sub

AIError:
    ' Uses HandleError procedure for consistent error handling
    HandleError "frm_RegisterEndpoint", "cmd_Cancel_Click", Err.Number, Err.description, Erl
    Resume AIExit
    
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: cmd_Save_Click
' PURPOSE: Validates and saves the new endpoint, then closes the form
' NOTES: Creates clEndpoint object and delegates to modDatabase.SaveEndpoint
'        Shows success message and closes form on successful save
'------------------------------------------------------------------------------
Private Sub cmd_Save_Click()
    On Error GoTo ErrorHandler
    
    ' Create new endpoint object to hold form data
    Dim epNewEndpoint As New clEndpoint
    
    ' Only proceed if validation passes
    If Me.ValidateRequired() Then
        ' Populate endpoint object with form data
        With epNewEndpoint
            .ShortName = Me.txt_EndpointShortName.Value
            .description = Me.txt_EndpointDescription.Value
        End With
    
        ' Attempt to save the endpoint using database module
        If modDatabase.SaveEndpoint(Me.txt_FormID, epNewEndpoint) = False Then
            MsgBox "An error occurred. Please try again."
            Exit Sub
        End If
    Else
        ' Validation failed, exit without saving
        Exit Sub
    End If
    
    ' Success: notify user and close form
    MsgBox "New endpoint created successfully!"  ' NOTE: Typo in "successfuly"
    Unload Me
        
ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "cmd_Save_Click", Err.Number, Err.description, Erl
    Resume ErrorExit
End Sub

'------------------------------------------------------------------------------
' EVENT HANDLER: cmd_SaveContinue_Click
' PURPOSE: Validates and saves the new endpoint, then clears form for next entry
' NOTES: Same logic as cmd_Save_Click but keeps form open and clears fields
'        Allows rapid entry of multiple endpoints in sequence
'------------------------------------------------------------------------------
Private Sub cmd_SaveContinue_Click()
    On Error GoTo ErrorHandler
    
    ' Create new endpoint object to hold form data
    Dim epNewEndpoint As New clEndpoint
    
    ' Only proceed if validation passes
    If Me.ValidateRequired() Then
        ' Populate endpoint object with form data
        With epNewEndpoint
            .ShortName = Me.txt_EndpointShortName.Value
            .description = Me.txt_EndpointDescription.Value
        End With
    
        ' Attempt to save the endpoint using database module
        If modDatabase.SaveEndpoint(Me.txt_FormID, epNewEndpoint) = False Then
            MsgBox "An error occurred. Please try again."
            Exit Sub
        End If
    Else
        ' Validation failed, exit without saving
        Exit Sub
    End If
    
    ' Success: notify user and prepare for next entry
    MsgBox "New endpoint created successfuly!"  ' NOTE: Typo in "successfuly"
    Me.Clear  ' Clear form fields for next endpoint entry
        
ErrorExit:
Exit Sub

ErrorHandler:
    ' Standardized error handling using HandleError procedure
    ' NOTE: Debug message references old form name - should be updated
    HandleError "frm_RegisterEndpoint", "cmd_SaveContinue_Click", Err.Number, Err.description, Erl
    Resume ErrorExit

End Sub
-------------------------------------------------------------------------------
VBA MACRO clEndpoint.cls 
in file: xl/vbaProject.bin - OLE stream: 'VBA/clEndpoint'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' Author: jorr@mtcarbine.com.au
' Date 24-12-24
Option Explicit

Private mShortName As String
Private mDescription As String

Public Property Get ShortName() As String
On Error GoTo AIError

    ShortName = mShortName

AIExit:
Exit Property

AIError:
    HandleError "clEndpoint", "ShortName", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let ShortName(strShortName As String)
On Error GoTo AIError

    mShortName = strShortName

AIExit:
Exit Property

AIError:
    HandleError "clEndpoint", "ShortName", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Get description() As String
On Error GoTo AIError

    description = mDescription

AIExit:
Exit Property

AIError:
    HandleError "clEndpoint", "Description", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

Public Property Let description(strDescription As String)
On Error GoTo AIError

    mDescription = strDescription

AIExit:
Exit Property

AIError:
    HandleError "clEndpoint", "Description", Err.Number, Err.description, Erl
    Resume AIExit
    
End Property

-------------------------------------------------------------------------------
VBA MACRO ModDiagnostics.bas 
in file: xl/vbaProject.bin - OLE stream: 'VBA/ModDiagnostics'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
' ===============================================================================
' MODULE: ModDiagnostics
' PURPOSE: Diagnostic tools to help debug the cable edit endpoint lookup failure
' ===============================================================================

Option Explicit

' ===============================================================================
' SUBROUTINE: DiagnoseEndpointLookup
' PURPOSE: Diagnoses why endpoint lookup is failing for a specific cable
' USAGE: Call this from Immediate Window:  DiagnoseEndpointLookup "CV103-C1001-CV103", "WET_PLANT"
' ===============================================================================
Public Sub DiagnoseEndpointLookup(cableID As String, strFormID As String)
    On Error GoTo ErrorHandler
    
    Debug.Print "==============================================="
    Debug.Print "ENDPOINT LOOKUP DIAGNOSTIC"
    Debug.Print "==============================================="
    Debug.Print "Cable ID: " & cableID
    Debug.Print "Plant Type: " & strFormID
    Debug.Print ""
    
    ' Get the cable object
    Dim tableIndex As Long
    tableIndex = FindCableRowIndex(cableID, strFormID)
    
    If tableIndex = 0 Then
        Debug.Print "? ERROR: Cable not found in table"
        Exit Sub
    End If
    
    Debug.Print "? Cable found at table row index: " & tableIndex
    Debug.Print ""
    
    ' Get cable data
    Dim cCable As clCable
    Set cCable = modDatabase.GetCableByRowIndex(strFormID, tableIndex)
    
    If cCable Is Nothing Then
        Debug.Print "? ERROR: Could not load cable data"
        Exit Sub
    End If
    
    Debug.Print "CABLE DATA FROM TABLE:"
    Debug.Print "  Source (stored): [" & cCable.Source & "]"
    Debug.Print "  Destination (stored): [" & cCable.Destination & "]"
    Debug.Print ""
    
    ' Get all endpoints for this plant
    Debug.Print "LOADING ENDPOINTS FOR " & strFormID & "..."
    Dim arrEndpoints As Variant
    arrEndpoints = sht_Data.GetEndpointsArray(strFormID)
    
    If Not IsArray(arrEndpoints) Then
        Debug.Print "? ERROR: Could not load endpoints array"
        Exit Sub
    End If
    
    Dim endpointCount As Long
    On Error Resume Next
    endpointCount = UBound(arrEndpoints) - LBound(arrEndpoints) + 1
    On Error GoTo ErrorHandler
    
    Debug.Print "? Found " & endpointCount & " endpoints"
    Debug.Print ""
    
    ' List all endpoints
    Debug.Print "ALL ENDPOINTS IN TABLE:"
    Debug.Print "Index | Short Name | Description"
    Debug.Print "------|------------|-------------"
    
    Dim i As Long
    Dim epItem As Variant
    For Each epItem In arrEndpoints
        Debug.Print "  " & i & "   | " & epItem.ShortName & " | " & epItem.description
        i = i + 1
    Next epItem
    Debug.Print ""
    
    ' Try to find source endpoint
    Debug.Print "SEARCHING FOR SOURCE ENDPOINT..."
    Debug.Print "  Looking for description: [" & cCable.Source & "]"
    
    Dim foundSource As Boolean
    foundSource = False
    Dim sourceShortName As String
    
    For Each epItem In arrEndpoints
        If StrComp(epItem.description, Trim(cCable.Source), vbTextCompare) = 0 Then
            foundSource = True
            sourceShortName = epItem.ShortName
            Debug.Print "  ? FOUND: Short Name = " & sourceShortName
            Exit For
        End If
    Next epItem
    
    If Not foundSource Then
        Debug.Print "  ? NOT FOUND"
        Debug.Print "  This is why the Source dropdown appears empty!"
        Debug.Print ""
        Debug.Print "  CHECKING FOR SIMILAR MATCHES..."
        For Each epItem In arrEndpoints
            If InStr(1, epItem.description, Trim(cCable.Source), vbTextCompare) > 0 Or _
               InStr(1, Trim(cCable.Source), epItem.description, vbTextCompare) > 0 Then
                Debug.Print "    Similar: " & epItem.ShortName & " - " & epItem.description
            End If
        Next epItem
    End If
    Debug.Print ""
    
    ' Try to find destination endpoint
    Debug.Print "SEARCHING FOR DESTINATION ENDPOINT..."
    Debug.Print "  Looking for description: [" & cCable.Destination & "]"
    
    Dim foundDest As Boolean
    foundDest = False
    Dim destShortName As String
    
    For Each epItem In arrEndpoints
        If StrComp(epItem.description, Trim(cCable.Destination), vbTextCompare) = 0 Then
            foundDest = True
            destShortName = epItem.ShortName
            Debug.Print "  ? FOUND: Short Name = " & destShortName
            Exit For
        End If
    Next epItem
    
    If Not foundDest Then
        Debug.Print "  ? NOT FOUND"
        Debug.Print "  This is why the Destination dropdown appears empty!"
        Debug.Print ""
        Debug.Print "  CHECKING FOR SIMILAR MATCHES..."
        For Each epItem In arrEndpoints
            If InStr(1, epItem.description, Trim(cCable.Destination), vbTextCompare) > 0 Or _
               InStr(1, Trim(cCable.Destination), epItem.description, vbTextCompare) > 0 Then
                Debug.Print "    Similar: " & epItem.ShortName & " - " & epItem.description
            End If
        Next epItem
    End If
    Debug.Print ""
    
    ' Provide recommendations
    Debug.Print "DIAGNOSIS SUMMARY:"
    Debug.Print "==============================================="
    
    If foundSource And foundDest Then
        Debug.Print "? Both endpoints found - lookup should work"
        Debug.Print "  If edit form still shows empty, check GetShortNameFromDescription function"
    Else
        Debug.Print "? Problem identified:"
        If Not foundSource Then
            Debug.Print "  - Source endpoint description doesn't match any endpoint in table"
        End If
        If Not foundDest Then
            Debug.Print "  - Destination endpoint description doesn't match any endpoint in table"
        End If
        Debug.Print ""
        Debug.Print "SOLUTION OPTIONS:"
        Debug.Print "1. Add the missing endpoint(s) to the endpoints table"
        Debug.Print "2. Update the cable record to use an existing endpoint"
        Debug.Print "3. Fix any spelling/spacing differences in descriptions"
    End If
    
    Debug.Print "==============================================="
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "? ERROR in diagnostic: " & Err.description
End Sub

' ===============================================================================
' FUNCTION: FindCableRowIndex
' PURPOSE: Finds the table row index for a cable by its ID
' ===============================================================================
Private Function FindCableRowIndex(cableID As String, strFormID As String) As Long
    On Error GoTo ErrorHandler
    
    Dim ws As Worksheet
    Dim tbl As ListObject
    Dim i As Long
    
    ' Determine which worksheet and table to search
    Select Case strFormID
        Case "WET_PLANT"
            Set ws = sht_WetPlant
            Set tbl = ws.ListObjects("tbl_WetPlantCables")
        Case "ORE_SORTER"
            Set ws = sht_OreSorter
            Set tbl = ws.ListObjects("tbl_OreSorterCables")
        Case "RETREATMENT"
            Set ws = sht_Retreatment
            Set tbl = ws.ListObjects("tbl_RetreatmentCables")
        Case Else
            FindCableRowIndex = 0
            Exit Function
    End Select
    
    ' Search for cable ID in column 3 (Cable ID column)
    For i = 1 To tbl.ListRows.count
        If StrComp(tbl.ListRows(i).Range(1, 3).Value, cableID, vbTextCompare) = 0 Then
            FindCableRowIndex = i
            Exit Function
        End If
    Next i
    
    ' Not found
    FindCableRowIndex = 0
    
    Exit Function
    
ErrorHandler:
    FindCableRowIndex = 0
End Function

' ===============================================================================
' SUBROUTINE: ListAllEndpoints
' PURPOSE: Lists all endpoints for a plant type
' USAGE: Call from Immediate Window:  ListAllEndpoints "WET_PLANT"
' ===============================================================================
Public Sub ListAllEndpoints(strFormID As String)
    On Error GoTo ErrorHandler
    
    Debug.Print "==============================================="
    Debug.Print "ALL ENDPOINTS FOR " & strFormID
    Debug.Print "==============================================="
    
    Dim arrEndpoints As Variant
    arrEndpoints = sht_Data.GetEndpointsArray(strFormID)
    
    If Not IsArray(arrEndpoints) Then
        Debug.Print "? ERROR: Could not load endpoints"
        Exit Sub
    End If
    
    Debug.Print "Short Name | Description"
    Debug.Print "-----------|-------------"
    
    Dim epItem As Variant
    For Each epItem In arrEndpoints
        Debug.Print epItem.ShortName & " | " & epItem.description
    Next epItem
    
    Debug.Print "==============================================="
    
    Exit Sub
    
ErrorHandler:
    Debug.Print "? ERROR: " & Err.description
End Sub
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahoma1.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Choose the source for the circuit from the dropdown list.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Cable ID	
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
H,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
1 - Source	
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
3 - Destination
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomais
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Core Size
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Configuration
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Insulation
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomam1
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Cable Typea
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahoma

-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Earth Sizea
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
    Length (m)a
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
TahomaPK
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
H,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomais
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomais
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomais
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomax/
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahoma!
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
2 - Circuit Name	
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
H,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomaxl
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
X,
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahoma.x
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Choose the destination for the circuit from the dropdown list.
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomam1
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Schedule
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Cancel
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Save & Continueeg
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Tahomale
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
,@@@
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
ID Securely Attached to both ends of Cable?
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
,@@@
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
0ahoSchedule Completedo
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterCable/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Create Endpoint
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterEndpoint/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Endpoint Short Name
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterEndpoint/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Endpoint Description
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterEndpoint/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
SaveE
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterEndpoint/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Save & Continue
-------------------------------------------------------------------------------
VBA FORM STRING IN 'xl/vbaProject.bin' - OLE stream: 'frm_RegisterEndpoint/o'
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Cancel
+----------+--------------------+---------------------------------------------+
|Type      |Keyword             |Description                                  |
+----------+--------------------+---------------------------------------------+
|AutoExec  |Workbook_Open       |Runs when the Excel Workbook is opened       |
|AutoExec  |txt_CableID_GotFocus|Runs when the file is opened and ActiveX     |
|          |                    |objects trigger events                       |
|AutoExec  |ShowNewWPPowerCableF|Runs when the file is opened and ActiveX     |
|          |orm_Click           |objects trigger events                       |
|AutoExec  |txt_CableID_Change  |Runs when the file is opened and ActiveX     |
|          |                    |objects trigger events                       |
|Suspicious|open                |May open a file                              |
|Suspicious|Write               |May write to a file (if combined with Open)  |
|Suspicious|Put                 |May write to a file (if combined with Open)  |
|Suspicious|output              |May write to a file (if combined with Open)  |
|Suspicious|binary              |May read or write a binary file (if combined |
|          |                    |with Open)                                   |
|Suspicious|Run                 |May run an executable file or a system       |
|          |                    |command                                      |
|Suspicious|Create              |May execute file or a system command through |
|          |                    |WMI                                          |
|Suspicious|command             |May run PowerShell commands                  |
|Suspicious|Call                |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|CreateObject        |May create an OLE object                     |
|Suspicious|Windows             |May enumerate application windows (if        |
|          |                    |combined with Shell.Application object)      |
|Suspicious|Lib                 |May run code from a DLL                      |
|Suspicious|libc.dylib          |May run code from a library on a Mac         |
|Suspicious|dylib               |May run code from a library on a Mac         |
|Suspicious|ChrW                |May attempt to obfuscate specific strings    |
|          |                    |(use option --deobf to deobfuscate)          |
|Suspicious|system              |May run an executable file or a system       |
|          |                    |command on a Mac (if combined with           |
|          |                    |libc.dylib)                                  |
|Suspicious|popen               |May run an executable file or a system       |
|          |                    |command on a Mac (if combined with           |
|          |                    |libc.dylib)                                  |
|Suspicious|Register            |May call a DLL using Excel 4 Macros (XLM/XLF)|
|Suspicious|Hex Strings         |Hex-encoded strings were detected, may be    |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|Suspicious|Base64 Strings      |Base64-encoded strings were detected, may be |
|          |                    |used to obfuscate strings (option --decode to|
|          |                    |see all)                                     |
|IOC       |https://github.com/V|URL                                          |
|          |BA-tools/VBA-JSON   |                                             |
|IOC       |http://www.opensourc|URL                                          |
|          |e.org/licenses/mit- |                                             |
|          |license.php         |                                             |
|IOC       |http://code.google.c|URL                                          |
|          |om/p/vba-json/      |                                             |
|IOC       |http://msdn.microsof|URL                                          |
|          |t.com/en-us/library/|                                             |
|          |windows/desktop/ms72|                                             |
|          |4421.aspx           |                                             |
|IOC       |http://msdn.microsof|URL                                          |
|          |t.com/en-us/library/|                                             |
|          |windows/desktop/ms72|                                             |
|          |4949.aspx           |                                             |
|IOC       |http://msdn.microsof|URL                                          |
|          |t.com/en-us/library/|                                             |
|          |windows/desktop/ms72|                                             |
|          |5485.aspx           |                                             |
|IOC       |http://support.micro|URL                                          |
|          |soft.com/kb/269370  |                                             |
|IOC       |http://www.ietf.org/|URL                                          |
|          |rfc/rfc4627.txt     |                                             |
|IOC       |https://support.micr|URL                                          |
|          |osoft.com/en-       |                                             |
|          |us/kb/272138        |                                             |
|IOC       |http://www.vbacceler|URL                                          |
|          |ator.com/home/VB/Cod|                                             |
|          |e/Techniques/RunTime|                                             |
|          |_Debug_Tracing/VB6_T|                                             |
|          |racer_Utility_zip_cS|                                             |
|          |tringBuilder_cls.asp|                                             |
|IOC       |https://github.com/V|URL                                          |
|          |BA-tools/VBA-       |                                             |
|          |JSON/pull/82        |                                             |
|IOC       |https://github.com/V|URL                                          |
|          |BA-tools/VBA-       |                                             |
|          |UtcConverter        |                                             |
|Hex String|'\x00\x02\x08\x19'  |00020819                                     |
|Hex String|'\x00\x00\x00\x00\x0|000000000046                                 |
|          |0F'                 |                                             |
|Hex String|'\x00\x02\x08 '     |00020820                                     |
|Hex String|'=*'              |FCFB3D2A                                     |
|Hex String|'\x08\x00+3q'      |08002B3371B5                                 |
|Hex String|'d'              |B9DD64D8                                     |
|Hex String|'g7'             |C7E4BE6737D4                                 |
|Hex String|"uE'"              |75458D27                                     |
|Hex String|'T[%\x1f'         |545BFD25BE1F                                 |
|Hex String|'\x01#Eg'          |0123456789                                   |
|Hex String|m+a:                |6D2B613A                                     |
|Hex String|'<\r'             |3C0DBAEA999D                                 |
|Hex String|'\x12Bf'           |12426693                                     |
|Hex String|'\x08k`)\x13'      |086BD4602913                                 |
|Base64    |'\x19KjQ\x03n'|GetLastRowNumber                             |
|String    |                    |                                             |
|Base64    |'\x19M{\x1bB.n|GetNextCircuitNumber                         |
|String    |'                 |                                             |
|Base64    |'\x19Dh{Si^5'|GetEndpointTableName                         |
|String    |                    |                                             |
|Base64    |'J\x1a0\x12wi)E"|ShowEndpointRegistrationForm                 |
|String    |*\'\x16'        |                                             |
|Base64    |'\nJ,'           |CoreSize                                     |
|String    |                    |                                             |
|Base64    |'T)l'            |modUtils                                     |
|String    |                    |                                             |
|Base64    |'\x11'             |Edit                                         |
|String    |                    |                                             |
|Base64    |'\x102\x13'         |EDIT                                         |
|String    |                    |                                             |
|Base64    |'}\x1f'            |feof                                         |
|String    |                    |                                             |
|Base64    |'e'               |null                                         |
|String    |                    |                                             |
|Base64    |''               |true                                         |
|String    |                    |                                             |
|Base64    |'='                |Peek                                         |
|String    |                    |                                             |
|Base64    |'I\x12wi)'      |SaveEndpoint                                 |
|String    |                    |                                             |
|Base64    |'2D+'            |ModError                                     |
|String    |                    |                                             |
|Base64    |'Ubu^E'        |ValidateRequired                             |
|String    |                    |                                             |
|Suspicious|VBA Stomping        |VBA Stomping was detected: the VBA source    |
|          |                    |code and P-code are different, this may have |
|          |                    |been used to hide malicious code             |
+----------+--------------------+---------------------------------------------+
VBA Stomping detection is experimental: please report any false positive/negative at https://github.com/decalage2/oletools/issues

ModuleNotFoundError: No module named '_cffi_backend'
thread '<unnamed>' panicked at /usr/share/cargo/registry/pyo3-0.20.2/src/err/mod.rs:788:5:
Python API call failed
stack backtrace:
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
Traceback (most recent call last):
  File "/usr/local/bin/olevba", line 8, in <module>
    sys.exit(main())
             ^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/oletools/olevba.py", line 4670, in main
    curr_return_code = process_file(filename, data, container, options)
                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/oletools/olevba.py", line 4503, in process_file
    if not crypto.is_encrypted(filename):
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/oletools/crypto.py", line 195, in is_encrypted
    return msoffcrypto.OfficeFile(file_handle).is_encrypted()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/usr/local/lib/python3.11/dist-packages/msoffcrypto/__init__.py", line 47, in OfficeFile
    from msoffcrypto.format.ooxml import OOXMLFile
  File "/usr/local/lib/python3.11/dist-packages/msoffcrypto/format/ooxml.py", line 13, in <module>
    from msoffcrypto.method.ecma376_agile import ECMA376Agile
  File "/usr/local/lib/python3.11/dist-packages/msoffcrypto/method/ecma376_agile.py", line 13, in <module>
    from cryptography.hazmat.primitives import serialization
  File "/usr/lib/python3/dist-packages/cryptography/hazmat/primitives/serialization/__init__.py", line 7, in <module>
    from cryptography.hazmat.primitives._serialization import (
  File "/usr/lib/python3/dist-packages/cryptography/hazmat/primitives/_serialization.py", line 11, in <module>
    from cryptography.hazmat.primitives.hashes import HashAlgorithm
  File "/usr/lib/python3/dist-packages/cryptography/hazmat/primitives/hashes.py", line 10, in <module>
    from cryptography.hazmat.bindings._rust import openssl as rust_openssl
pyo3_runtime.PanicException: Python API call failed
